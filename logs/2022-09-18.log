{
  message: {
    err_no: 0,
    err_msg: 'success',
    data: {
      booklet: {
        booklet_id: '7050063811973218341',
        base_info: {
          id: 0,
          booklet_id: '7050063811973218341',
          title: '深入浅出 Vite',
          price: 4990,
          category_id: '6809637767543259144',
          status: 1,
          user_id: '430664257382462',
          verify_status: 4,
          summary: '系统化学习现代构建工具 Vite，提升前端工程化能力',
          cover_img: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cb255da618249d0857e6ecfc5017340~tplv-k3u1fbpfcp-watermark.image?',
          section_count: 28,
          section_ids: '7050063811994189855|7050063812044685343|7077834799208988675|7053634868994899975|7057872229589057576|7058853948060336163|7058854154738860066|7058947037877764137|7060398408430780431|7060405118163746850|7061788120680759331|7061854307863232547|7065976180125466638|7065976180020609032|7066601785166659620|7066611951547187214|7066612265536978981|7068105121523531806|7068105121615314952|7066612739912761352|7066614740574797832|7066617580068274207|7066617652487127077|7066617769776644126|7066613178028785700|7066613452235603982|7066614663533821983|7070419010021490702|7120588458145349640',
          is_finished: 1,
          ctime: 1642386948,
          mtime: 1663056711,
          put_on_time: 1649235586,
          pull_off_time: -62135596800,
          finished_time: -62135596800,
          recycle_bin_time: -62135596800,
          verify_time: -62135596800,
          submit_time: 1663056711,
          top_time: 1649235611,
          wechat_group_img: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/876f8a0a3e914e9fb741641d63f8f928~tplv-k3u1fbpfcp-watermark.image?',
          wechat_group_desc: '',
          wechat_group_signal: 'Vite406',
          read_time: 72858,
          buy_count: 3027,
          course_type: 1,
          background_img: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f0be63544f24e5da59ced8854807b3d~tplv-k3u1fbpfcp-watermark.image?',
          is_distribution: 1,
          distribution_img: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1eaed56ad91747119f006f425e408ee2~tplv-k3u1fbpfcp-zoom-1.image?',
          commission: 998,
          can_vip_borrow: false
        },
        user_info: {
          user_id: '430664257382462',
          user_name: '神三元',
          company: '字节跳动',
          job_title: '公众号 「三元同学」',
          avatar_large: 'https://p9-passport.byteacctimg.com/img/user-avatar/d43ef01b284d645d6d7ab02c8dc32aaa~300x300.image',
          level: 7,
          description: '掘金小册《深入浅出 Vite》、《React Hooks 与 Immutable 数据流实战》作者，目前就职于字节跳动前端架构团队',
          followee_count: 77,
          follower_count: 33844,
          post_article_count: 50,
          digg_article_count: 451,
          got_digg_count: 32338,
          got_view_count: 1622666,
          post_shortmsg_count: 36,
          digg_shortmsg_count: 30,
          isfollowed: false,
          favorable_author: 1,
          power: 97566,
          study_point: 0,
          university: { university_id: '0', name: '', logo: '' },
          major: { major_id: '0', parent_id: '0', name: '' },
          student_status: 0,
          select_event_count: 0,
          select_online_course_count: 0,
          identity: 0,
          is_select_annual: true,
          select_annual_rank: 0,
          annual_list_type: 0,
          extraMap: {},
          is_logout: 0,
          annual_info: [],
          account_amount: 0,
          user_growth_info: {
            user_id: 430664257382462,
            jpower: 97566,
            jscore: 1598.2,
            jpower_level: 7,
            jscore_level: 5,
            jscore_title: '先锋掘友',
            author_achievement_list: [ 1 ],
            vip_level: 0,
            vip_title: '',
            jscore_next_level_score: 4656510908468560000
          },
          is_vip: false
        },
        is_buy: true,
        reading_progress: {
          id: 0,
          booklet_id: '7050063811973218341',
          user_id: '3289337926283534',
          status: 1,
          buy_type: 1,
          reading_end: 0,
          reading_progress: 79,
          last_section_id: '7050063812044685343',
          has_update: 1,
          last_rtime: 1663479493,
          ctime: 1656157385,
          mtime: 1663479627,
          valid_begin_time: 0,
          valid_end_time: 0,
          borrow_times: 0
        },
        section_updated_count: 28,
        is_new: false
      },
      introduction: {
        id: 85821,
        section_id: '7050063811994189855',
        title: '小册介绍',
        user_id: '430664257382462',
        booklet_id: '7050063811973218341',
        status: 1,
        content: '<h2>你将获得</h2>\n' +
          '<ul>\n' +
          '<li>\n' +
          '<p>5 大模块，详细梳理构建工具实战要点</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>深入底层，彻底搞懂 Vite 原理与实现</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>真实场景，攻克工程实践中的核心问题</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>从 0 到 1，手把手教你实现构建引擎</p>\n' +
          '</li>\n' +
          '</ul>\n' +
          '<h2>作者介绍</h2>\n' +
          '<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bb5087ddc334879a84ba032696ad185~tplv-k3u1fbpfcp-watermark.image?" alt="20220323稀土掘金-「小册」《深入浅出 Vite 》视觉延展 - 改1_作者简介.jpg"></p>\n' +
          '<p>目前深耕前端工程化构建领域，拥有大量的 Vite 工程化实战和性能优化经验，曾将 Vite 落地到抖音直播 PC 端等公司大型业务中，也是 Vite Contributor。</p>\n' +
          '<h2>小册介绍</h2>\n' +
          '<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cde068a9356b4b53b53bf8a7199888ea~tplv-k3u1fbpfcp-watermark.image?" alt="课程介绍(1624x623).png"></p>\n' +
          '<p>随着前端技术的发展，构建工具所做的事情早已不仅仅是<code>打包代码</code> 那么简单，如今它已经贯穿了前端项目的整个生命周期，在前端工程化中占据了越来越核心的位置。而由于前端项目规模的日益庞大，传统的构建工具已经无法满足开发者们对 DX(Developer Experience，即开发者体验) 的要求。在使用传统工具的过程中，我们经常会遇到这样的问题:</p>\n' +
          '<ul>\n' +
          '<li>\n' +
          '<p><strong>漫长的项目启动时间</strong>。作为开发者，经常要等待几分钟的时间才能看到项目启动完成。</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p><strong>漫长的热更新时间</strong>。热更新要花费数秒的时间，代码改动后反馈非常迟钝，而且随着项目规模越来越大，热更新也越来越慢。</p>\n' +
          '</li>\n' +
          '</ul>\n' +
          '<p>为了解决上述的问题，Vite 在一系列方案中脱颖而出。相比于传统的构建工具，Vite 项目启动时间能缩短 90% 以上，热更新能得到毫秒级的响应，给构建性能带来了一个量级的提升，极大地解决了大家的开发体验痛点。而回看社区，最近的 JavaScript 生态的年度调查结果也显示，Vite 的开发满意度超过 98%，成为整个前端社区中最受瞩目的技术。</p>\n' +
          '<p>因此，如果你现在要学习构建工具，Vite 将会是一个更好的选择。但很多人在学习和应用 Vite 的过程中总会遇到下面的问题:</p>\n' +
          '<ul>\n' +
          '<li>\n' +
          '<p>缺少系统化的学习资料，社区中绝大多数的文章仅仅只是教会你如何搭建一个简单的脚手架项目，不够系统和深入</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>不了解 Vite 相关的生态，遇到问题的时候不知道使用哪些插件或者解决方案</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>不熟悉 Esbuild、Rollup 这些底层构建引擎，遇到一些稍微需要定制的场景就感到捉襟见肘</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>不知道如何将 Vite 和其它前端工具结合，如 <code>Babel</code>、<code>core-js</code></p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>构建工具源码晦涩难懂，对更深一步的原理学习望而却步</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>......</p>\n' +
          '</li>\n' +
          '</ul>\n' +
          '<p>在本课程中，我会给大家系统梳理 Vite 知识，并解决如上种种问题，带大家了解到前端工程的构建中究竟具备哪些知识和技能，不光是 Vite 本身的知识，也包括 Vite 底层所使用的 Esbuild、Rollup 双引擎、Babel 编译工具链、模块规范标准等一系列构建生态，从此掌握前端构建领域的第一性原理，完成从构建小白到高手的蜕变。</p>\n' +
          '<p>在本课程中，我分了五个部分来系统讲述:</p>\n' +
          '<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94af3f775bd64fbaaaf71d7555f2311d~tplv-k3u1fbpfcp-watermark.image?" alt="深入浅出 Vite (2).png"></p>\n' +
          '<ol>\n' +
          '<li>\n' +
          '<p><strong>基础使用篇。</strong> 重新认识构建工具本身的价值，学会 Vite 基本的功能使用，让你能够独立搭建一个相对完整的脚手架项目。</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p><strong>双引擎篇。</strong> 这个部分我会给你详细介绍 Vite 的双引擎架构，并带你系统学习 Esbuild 和 Rollup 相关的内容，掌握<code>最小必要知识</code>，为后续的高级应用作铺垫。</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p><strong>高级应用篇。</strong> 你将学习到 Vite 的各种高级用法和构建性能优化手段，全程高能实战，每一节都有具体可运行的示例项目。</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p><strong>源码精读篇。</strong> 在这个部分我们将剖析 Vite 的核心源码，理解诸如<code>JIT</code>、<code>Proxy Module</code>、<code>Module Graph</code>、<code>HMR Boundary</code>、<code>Plugin Container</code> 等源码中重要概念的作用及其底层实现。</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p><strong>手写实战篇。</strong> 一方面我们会手写 Vite 的开发时 no-bundle 服务，另一方面也会带你一步步完成一个生产环境打包工具(Bundler)，从 AST 解析的功能开始，最终实现一个 Bundler。</p>\n' +
          '</li>\n' +
          '</ol>\n' +
          '<p>小册最大的特点就是基于实战，理论固然重要，但更重要的是上手实操，几乎所有的知识点你都能找到对应的示例实现代码，在课程的最后一章甚至会手把手教你写一个构建引擎。正如这句话所说:</p>\n' +
          '<blockquote>\n' +
          '<p>Talk is cheap， show me your code.</p>\n' +
          '</blockquote>\n' +
          '<p>希望这本小册能够降低你学习构建工具的门槛，带你真正完成从入门到进阶的过程。虽然本小册并不能解决所有的问题，但我在小册中分享的个人学习经验，以及面对问题时的思维方式或许给你带来一些启发。</p>\n' +
          '<p>祝学习愉快，我们小册中见！</p>\n' +
          '<h2>你会学到什么？</h2>\n' +
          '<ul>\n' +
          '<li>\n' +
          '<p>熟练掌握 Vite 的使用，<code>独立搭建</code>完整的前端工程环境以及工作流；</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>学会 Vite <code>插件开发</code>及项目<code>性能优化</code>技巧，独立解决 Vite 使用过程中的核心难题；</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>深入掌握 Vite 底层用到的打包工具 <code>Esbuild</code> 和 <code>Rollup</code>，学会核心的打包配置和插件开发姿势；</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>彻底理解 Vite 实现原理，学会 Vite 背后的优秀<code>架构思想</code>和<code>核心实现</code>；</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>从 0 到 1 手写构建工具，掌握前端构建工具的原理。</p>\n' +
          '</li>\n' +
          '</ul>\n' +
          '<h2>适宜人群</h2>\n' +
          '<ul>\n' +
          '<li>想要系统学习 Vite，提升竞争力，但没有接触过，也缺少项目经历</li>\n' +
          '<li>想通过 Vite 作为团队或者个人项目的技术栈，但对 Vite 的核心概念和进阶用法一知半解</li>\n' +
          '<li>想系统化学习 Rollup 和 Esbuild，理解构建工具的底层原理及源码实现，苦于学习门槛高</li>\n' +
          '</ul>\n' +
          '<h2>购买须知</h2>\n' +
          '<ol>\n' +
          '<li>本小册为图文形式虚拟内容服务，购买成功概不退款；</li>\n' +
          '<li>小册于 2022 年 04 月 06 日上线，全部章节现已完成更新；</li>\n' +
          '<li>购买用户可享有永久阅读权限，可进入小册微信群，与作者互动；</li>\n' +
          '<li>掘金小册版权归北京北比信息技术有限公司所有，任何机构、媒体、网站或个人未经本网协议授权不得转载、链接、转贴或以其他方式复制发布/发表，违者将依法追究责任；</li>\n' +
          '<li>在掘金小册阅读过程中，如有任何问题，请邮件联系 <a href="mailto:xiaoce@xitu.io">xiaoce@xitu.io</a></li>\n' +
          '</ol>',
        draft_content: '',
        draft_title: '小册介绍',
        markdown_content: '',
        markdown_show: '',
        is_free: 0,
        read_time: 320,
        read_count: 0,
        comment_count: 0,
        ctime: 1641716764,
        mtime: 1641716764,
        is_update: 0,
        draft_read_time: 0,
        vid: '',
        reading_progress: null
      },
      sections: [
        {
          id: 85822,
          section_id: '7050063812044685343',
          title: '开篇 ：让 Vite 助力你的前端工程化之路',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '开篇 ：让 Vite 助力你的前端工程化之路',
          markdown_content: '',
          markdown_show: '',
          is_free: 1,
          read_time: 510,
          read_count: 13485,
          comment_count: 53,
          ctime: 1641716764,
          mtime: 1641716764,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7050063812044685343',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 17,
            has_update: 1,
            last_rtime: 1663479493,
            ctime: 1656236051,
            mtime: 1663479492
          }
        },
        {
          id: 86674,
          section_id: '7077834799208988675',
          title: '模块标准：为什么 ESM 是前端模块化的未来？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '模块标准：为什么 ESM 是前端模块化的未来？',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 1988,
          read_count: 8291,
          comment_count: 37,
          ctime: 1648023179,
          mtime: 1648023179,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7077834799208988675',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 17,
            has_update: 1,
            last_rtime: 1663479116,
            ctime: 1656247440,
            mtime: 1663479276
          }
        },
        {
          id: 85932,
          section_id: '7053634868994899975',
          title: '快速上手: 如何用 Vite 从零搭建前端项目？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '快速上手: 如何用 Vite 从零搭建前端项目？',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 1229,
          read_count: 8436,
          comment_count: 61,
          ctime: 1642328835,
          mtime: 1642328835,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7053634868994899975',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1663414495,
            ctime: 1656247440,
            mtime: 1663414494
          }
        },
        {
          id: 86098,
          section_id: '7057872229589057576',
          title: '样式方案：在 Vite 中接入现代化的 CSS 工程化方案',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '样式方案：在 Vite 中接入现代化的 CSS 工程化方案',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 2084,
          read_count: 8055,
          comment_count: 83,
          ctime: 1643517556,
          mtime: 1643517556,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7057872229589057576',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1663414496,
            ctime: 1656249641,
            mtime: 1663414495
          }
        },
        {
          id: 86100,
          section_id: '7058853948060336163',
          title: '代码规范: 如何利用 Lint 工具链来保证代码风格和质量？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '代码规范: 如何利用 Lint 工具链来保证代码风格和质量？',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 2201,
          read_count: 7528,
          comment_count: 94,
          ctime: 1643539182,
          mtime: 1643539182,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7058853948060336163',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1663414496,
            ctime: 1656249660,
            mtime: 1663414496
          }
        },
        {
          id: 86101,
          section_id: '7058854154738860066',
          title: '静态资源: 如何在 Vite 中处理各种静态资源？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '静态资源: 如何在 Vite 中处理各种静态资源？',
          markdown_content: '',
          markdown_show: '',
          is_free: 1,
          read_time: 2547,
          read_count: 8514,
          comment_count: 60,
          ctime: 1643634078,
          mtime: 1643634078,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7058854154738860066',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1663414497,
            ctime: 1656467574,
            mtime: 1663414496
          }
        },
        {
          id: 86102,
          section_id: '7058947037877764137',
          title: '预构建: 如何玩转秒级依赖预构建的能力？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '预构建: 如何玩转秒级依赖预构建的能力？',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 1265,
          read_count: 5796,
          comment_count: 63,
          ctime: 1643727625,
          mtime: 1643727625,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7058947037877764137',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1663414498,
            ctime: 1656668570,
            mtime: 1663414497
          }
        },
        {
          id: 86113,
          section_id: '7060398408430780431',
          title: '双引擎架构: Vite 是如何站在巨人的肩膀上实现的？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '双引擎架构: Vite 是如何站在巨人的肩膀上实现的？',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 799,
          read_count: 4794,
          comment_count: 37,
          ctime: 1643878668,
          mtime: 1643878668,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7060398408430780431',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1663296029,
            ctime: 1656854321,
            mtime: 1663295639
          }
        },
        {
          id: 86117,
          section_id: '7060405118163746850',
          title: '得力的性能推手: Esbuild 功能使用与插件开发实战',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '得力的性能推手: Esbuild 功能使用与插件开发实战',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 3199,
          read_count: 5126,
          comment_count: 50,
          ctime: 1644047375,
          mtime: 1644047375,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7060405118163746850',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1663297715,
            ctime: 1656856344,
            mtime: 1663297713
          }
        },
        {
          id: 86128,
          section_id: '7061788120680759331',
          title: 'Vite 构建基石(上)——Rollup 打包基本概念及使用',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: 'Vite 构建基石(上)——Rollup 打包基本概念及使用',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 1853,
          read_count: 4183,
          comment_count: 15,
          ctime: 1644216084,
          mtime: 1644216084,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7061788120680759331',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1663297717,
            ctime: 1656856661,
            mtime: 1663297715
          }
        },
        {
          id: 86129,
          section_id: '7061854307863232547',
          title: 'Vite 构建基石(下)——深入理解 Rollup 的插件机制',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: 'Vite 构建基石(下)——深入理解 Rollup 的插件机制',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 2368,
          read_count: 3987,
          comment_count: 26,
          ctime: 1644221068,
          mtime: 1644221068,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7061854307863232547',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1663297721,
            ctime: 1656925341,
            mtime: 1663295587
          }
        },
        {
          id: 86299,
          section_id: '7065976180125466638',
          title: '插件开发与实战: 如何开发一个完整的 Vite 插件？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '插件开发与实战: 如何开发一个完整的 Vite 插件？',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 2912,
          read_count: 3577,
          comment_count: 29,
          ctime: 1645323809,
          mtime: 1645323809,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7065976180125466638',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1663297724,
            ctime: 1656990961,
            mtime: 1663297721
          }
        },
        {
          id: 86298,
          section_id: '7065976180020609032',
          title: 'HMR API 及原理：代码改动后，如何进行毫秒级别的局部更新？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: 'HMR API 及原理：代码改动后，如何进行毫秒级别的局部更新？',
          markdown_content: '',
          markdown_show: '',
          is_free: 1,
          read_time: 1897,
          read_count: 3501,
          comment_count: 15,
          ctime: 1645321442,
          mtime: 1645321442,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7065976180020609032',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1658124913,
            ctime: 1656990965,
            mtime: 1658122644
          }
        },
        {
          id: 86300,
          section_id: '7066601785166659620',
          title: '代码分割：打包完产物体积太大，怎么拆包？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '代码分割：打包完产物体积太大，怎么拆包？',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 2005,
          read_count: 2955,
          comment_count: 29,
          ctime: 1645323882,
          mtime: 1645323882,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7066601785166659620',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 57,
            has_update: 1,
            last_rtime: 1663307890,
            ctime: 1656852612,
            mtime: 1663297724
          }
        },
        {
          id: 86301,
          section_id: '7066611951547187214',
          title: '语法降级与Polyfill：联合前端编译工具链，消灭低版本浏览器兼容问题',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '语法降级与Polyfill：联合前端编译工具链，消灭低版本浏览器兼容问题',
          markdown_content: '',
          markdown_show: '',
          is_free: 1,
          read_time: 2221,
          read_count: 3095,
          comment_count: 38,
          ctime: 1645323993,
          mtime: 1645323993,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7066611951547187214',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1658212839,
            ctime: 1657010153,
            mtime: 1658212830
          }
        },
        {
          id: 86302,
          section_id: '7066612265536978981',
          title: ' 预渲染：如何借助 Vite 搭建高可用的服务端渲染(SSR)工程？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: ' 预渲染：如何借助 Vite 搭建高可用的服务端渲染(SSR)工程？',
          markdown_content: '',
          markdown_show: '',
          is_free: 1,
          read_time: 4085,
          read_count: 2104,
          comment_count: 21,
          ctime: 1645324095,
          mtime: 1645324095,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7066612265536978981',
            reading_end: 0,
            reading_progress: 0,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1658137091,
            ctime: 1658137089,
            mtime: 1658137089
          }
        },
        {
          id: 86369,
          section_id: '7068105121523531806',
          title: '模块联邦: 如何实现优雅的跨应用代码共享？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '模块联邦: 如何实现优雅的跨应用代码共享？',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 2450,
          read_count: 2018,
          comment_count: 27,
          ctime: 1645711673,
          mtime: 1645711673,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7068105121523531806',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 7,
            has_update: 1,
            last_rtime: 1660293640,
            ctime: 1658136482,
            mtime: 1660293221
          }
        },
        {
          id: 86370,
          section_id: '7068105121615314952',
          title: '再谈 ESM：高阶特性 & Pure ESM 时代',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '再谈 ESM：高阶特性 & Pure ESM 时代',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 1543,
          read_count: 1616,
          comment_count: 7,
          ctime: 1645711754,
          mtime: 1645711754,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7068105121615314952',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1658137093,
            ctime: 1658135862,
            mtime: 1658137093
          }
        },
        {
          id: 86303,
          section_id: '7066612739912761352',
          title: '性能优化:  如何体系化地对 Vite 项目进行性能优化？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '性能优化:  如何体系化地对 Vite 项目进行性能优化？',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 1790,
          read_count: 1886,
          comment_count: 8,
          ctime: 1645324159,
          mtime: 1645324159,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7066612739912761352',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 94,
            has_update: 1,
            last_rtime: 1658221145,
            ctime: 1658135858,
            mtime: 1658220178
          }
        },
        {
          id: 86307,
          section_id: '7066614740574797832',
          title: '配置解析服务：配置文件在 Vite 内部被转换成什么样子了？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '配置解析服务：配置文件在 Vite 内部被转换成什么样子了？',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 2223,
          read_count: 1771,
          comment_count: 9,
          ctime: 1645325120,
          mtime: 1645325120,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7066614740574797832',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1663296964,
            ctime: 1658140136,
            mtime: 1663296062
          }
        },
        {
          id: 86309,
          section_id: '7066617580068274207',
          title: '依赖预构建：Esbuild 打包功能如何被 Vite 玩出花来？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '依赖预构建：Esbuild 打包功能如何被 Vite 玩出花来？',
          markdown_content: '',
          markdown_show: '',
          is_free: 1,
          read_time: 3510,
          read_count: 2914,
          comment_count: 15,
          ctime: 1645325164,
          mtime: 1645325164,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7066617580068274207',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1663297701,
            ctime: 1658210387,
            mtime: 1663296973
          }
        },
        {
          id: 86310,
          section_id: '7066617652487127077',
          title: '插件流水线：从整体到局部，理解 Vite 的核心编译能力',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '插件流水线：从整体到局部，理解 Vite 的核心编译能力',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 4236,
          read_count: 1695,
          comment_count: 3,
          ctime: 1645325174,
          mtime: 1645325174,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: null
        },
        {
          id: 86311,
          section_id: '7066617769776644126',
          title: ' 热更新：基于 ESM 的毫秒级 HMR 的实现揭秘',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: ' 热更新：基于 ESM 的毫秒级 HMR 的实现揭秘',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 3246,
          read_count: 1644,
          comment_count: 5,
          ctime: 1645325199,
          mtime: 1645325199,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7066617769776644126',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1658214504,
            ctime: 1658214196,
            mtime: 1658214196
          }
        },
        {
          id: 86304,
          section_id: '7066613178028785700',
          title: '手写 Vite: 实现 no-bundle 开发服务(上)',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '手写 Vite: 实现 no-bundle 开发服务(上)',
          markdown_content: '',
          markdown_show: '',
          is_free: 1,
          read_time: 5486,
          read_count: 2636,
          comment_count: 35,
          ctime: 1645324441,
          mtime: 1645324441,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: null
        },
        {
          id: 86305,
          section_id: '7066613452235603982',
          title: '手写 Vite: 实现 no-bundle 开发服务(下)',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '手写 Vite: 实现 no-bundle 开发服务(下)',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 5567,
          read_count: 1377,
          comment_count: 10,
          ctime: 1645324459,
          mtime: 1645324459,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7066613452235603982',
            reading_end: 0,
            reading_progress: 0,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1658220176,
            ctime: 1658220174,
            mtime: 1658220174
          }
        },
        {
          id: 86306,
          section_id: '7066614663533821983',
          title: '手写 Bundler:  实现 JavaScript AST 解析器——词法分析、语义分析',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '手写 Bundler:  实现 JavaScript AST 解析器——词法分析、语义分析',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 3103,
          read_count: 1221,
          comment_count: 7,
          ctime: 1645324758,
          mtime: 1645324758,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: null
        },
        {
          id: 86413,
          section_id: '7070419010021490702',
          title: '手写 Bundler: 实现代码打包、 Tree Shaking ',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '手写 Bundler: 实现代码打包、 Tree Shaking ',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 6312,
          read_count: 1336,
          comment_count: 7,
          ctime: 1646220146,
          mtime: 1646220146,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7070419010021490702',
            reading_end: 0,
            reading_progress: 16,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1658210387,
            ctime: 1657001962,
            mtime: 1658210383
          }
        },
        {
          id: 87553,
          section_id: '7120588458145349640',
          title: '加餐: Vite 3.0 核心更新盘点与分析',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '加餐: Vite 3.0 核心更新盘点与分析',
          markdown_content: '',
          markdown_show: '',
          is_free: 1,
          read_time: 889,
          read_count: 946,
          comment_count: 2,
          ctime: 1657959737,
          mtime: 1657959737,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7120588458145349640',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1663296973,
            ctime: 1658210346,
            mtime: 1663296969
          }
        }
      ]
    }
  },
  level: 'info',
  label: 'juejin',
  timestamp: '2022-09-18 01:42:06.047 PM'
}
{
  message: {
    err_no: 0,
    err_msg: 'success',
    data: {
      booklet: {
        booklet_id: '7050063811973218341',
        base_info: {
          id: 0,
          booklet_id: '7050063811973218341',
          title: '深入浅出 Vite',
          price: 4990,
          category_id: '6809637767543259144',
          status: 1,
          user_id: '430664257382462',
          verify_status: 4,
          summary: '系统化学习现代构建工具 Vite，提升前端工程化能力',
          cover_img: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cb255da618249d0857e6ecfc5017340~tplv-k3u1fbpfcp-watermark.image?',
          section_count: 28,
          section_ids: '7050063811994189855|7050063812044685343|7077834799208988675|7053634868994899975|7057872229589057576|7058853948060336163|7058854154738860066|7058947037877764137|7060398408430780431|7060405118163746850|7061788120680759331|7061854307863232547|7065976180125466638|7065976180020609032|7066601785166659620|7066611951547187214|7066612265536978981|7068105121523531806|7068105121615314952|7066612739912761352|7066614740574797832|7066617580068274207|7066617652487127077|7066617769776644126|7066613178028785700|7066613452235603982|7066614663533821983|7070419010021490702|7120588458145349640',
          is_finished: 1,
          ctime: 1642386948,
          mtime: 1663056711,
          put_on_time: 1649235586,
          pull_off_time: -62135596800,
          finished_time: -62135596800,
          recycle_bin_time: -62135596800,
          verify_time: -62135596800,
          submit_time: 1663056711,
          top_time: 1649235611,
          wechat_group_img: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/876f8a0a3e914e9fb741641d63f8f928~tplv-k3u1fbpfcp-watermark.image?',
          wechat_group_desc: '',
          wechat_group_signal: 'Vite406',
          read_time: 72858,
          buy_count: 3027,
          course_type: 1,
          background_img: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f0be63544f24e5da59ced8854807b3d~tplv-k3u1fbpfcp-watermark.image?',
          is_distribution: 1,
          distribution_img: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1eaed56ad91747119f006f425e408ee2~tplv-k3u1fbpfcp-zoom-1.image?',
          commission: 998,
          can_vip_borrow: false
        },
        user_info: {
          user_id: '430664257382462',
          user_name: '神三元',
          company: '字节跳动',
          job_title: '公众号 「三元同学」',
          avatar_large: 'https://p9-passport.byteacctimg.com/img/user-avatar/d43ef01b284d645d6d7ab02c8dc32aaa~300x300.image',
          level: 7,
          description: '掘金小册《深入浅出 Vite》、《React Hooks 与 Immutable 数据流实战》作者，目前就职于字节跳动前端架构团队',
          followee_count: 77,
          follower_count: 33844,
          post_article_count: 50,
          digg_article_count: 451,
          got_digg_count: 32338,
          got_view_count: 1622666,
          post_shortmsg_count: 36,
          digg_shortmsg_count: 30,
          isfollowed: false,
          favorable_author: 1,
          power: 97566,
          study_point: 0,
          university: { university_id: '0', name: '', logo: '' },
          major: { major_id: '0', parent_id: '0', name: '' },
          student_status: 0,
          select_event_count: 0,
          select_online_course_count: 0,
          identity: 0,
          is_select_annual: true,
          select_annual_rank: 0,
          annual_list_type: 0,
          extraMap: {},
          is_logout: 0,
          annual_info: [],
          account_amount: 0,
          user_growth_info: {
            user_id: 430664257382462,
            jpower: 97566,
            jscore: 1598.2,
            jpower_level: 7,
            jscore_level: 5,
            jscore_title: '先锋掘友',
            author_achievement_list: [ 1 ],
            vip_level: 0,
            vip_title: '',
            jscore_next_level_score: 4656510908468560000
          },
          is_vip: false
        },
        is_buy: true,
        reading_progress: {
          id: 0,
          booklet_id: '7050063811973218341',
          user_id: '3289337926283534',
          status: 1,
          buy_type: 1,
          reading_end: 0,
          reading_progress: 79,
          last_section_id: '7050063812044685343',
          has_update: 1,
          last_rtime: 1663479493,
          ctime: 1656157385,
          mtime: 1663479726,
          valid_begin_time: 0,
          valid_end_time: 0,
          borrow_times: 0
        },
        section_updated_count: 28,
        is_new: false
      },
      introduction: {
        id: 85821,
        section_id: '7050063811994189855',
        title: '小册介绍',
        user_id: '430664257382462',
        booklet_id: '7050063811973218341',
        status: 1,
        content: '<h2>你将获得</h2>\n' +
          '<ul>\n' +
          '<li>\n' +
          '<p>5 大模块，详细梳理构建工具实战要点</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>深入底层，彻底搞懂 Vite 原理与实现</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>真实场景，攻克工程实践中的核心问题</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>从 0 到 1，手把手教你实现构建引擎</p>\n' +
          '</li>\n' +
          '</ul>\n' +
          '<h2>作者介绍</h2>\n' +
          '<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bb5087ddc334879a84ba032696ad185~tplv-k3u1fbpfcp-watermark.image?" alt="20220323稀土掘金-「小册」《深入浅出 Vite 》视觉延展 - 改1_作者简介.jpg"></p>\n' +
          '<p>目前深耕前端工程化构建领域，拥有大量的 Vite 工程化实战和性能优化经验，曾将 Vite 落地到抖音直播 PC 端等公司大型业务中，也是 Vite Contributor。</p>\n' +
          '<h2>小册介绍</h2>\n' +
          '<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cde068a9356b4b53b53bf8a7199888ea~tplv-k3u1fbpfcp-watermark.image?" alt="课程介绍(1624x623).png"></p>\n' +
          '<p>随着前端技术的发展，构建工具所做的事情早已不仅仅是<code>打包代码</code> 那么简单，如今它已经贯穿了前端项目的整个生命周期，在前端工程化中占据了越来越核心的位置。而由于前端项目规模的日益庞大，传统的构建工具已经无法满足开发者们对 DX(Developer Experience，即开发者体验) 的要求。在使用传统工具的过程中，我们经常会遇到这样的问题:</p>\n' +
          '<ul>\n' +
          '<li>\n' +
          '<p><strong>漫长的项目启动时间</strong>。作为开发者，经常要等待几分钟的时间才能看到项目启动完成。</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p><strong>漫长的热更新时间</strong>。热更新要花费数秒的时间，代码改动后反馈非常迟钝，而且随着项目规模越来越大，热更新也越来越慢。</p>\n' +
          '</li>\n' +
          '</ul>\n' +
          '<p>为了解决上述的问题，Vite 在一系列方案中脱颖而出。相比于传统的构建工具，Vite 项目启动时间能缩短 90% 以上，热更新能得到毫秒级的响应，给构建性能带来了一个量级的提升，极大地解决了大家的开发体验痛点。而回看社区，最近的 JavaScript 生态的年度调查结果也显示，Vite 的开发满意度超过 98%，成为整个前端社区中最受瞩目的技术。</p>\n' +
          '<p>因此，如果你现在要学习构建工具，Vite 将会是一个更好的选择。但很多人在学习和应用 Vite 的过程中总会遇到下面的问题:</p>\n' +
          '<ul>\n' +
          '<li>\n' +
          '<p>缺少系统化的学习资料，社区中绝大多数的文章仅仅只是教会你如何搭建一个简单的脚手架项目，不够系统和深入</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>不了解 Vite 相关的生态，遇到问题的时候不知道使用哪些插件或者解决方案</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>不熟悉 Esbuild、Rollup 这些底层构建引擎，遇到一些稍微需要定制的场景就感到捉襟见肘</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>不知道如何将 Vite 和其它前端工具结合，如 <code>Babel</code>、<code>core-js</code></p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>构建工具源码晦涩难懂，对更深一步的原理学习望而却步</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>......</p>\n' +
          '</li>\n' +
          '</ul>\n' +
          '<p>在本课程中，我会给大家系统梳理 Vite 知识，并解决如上种种问题，带大家了解到前端工程的构建中究竟具备哪些知识和技能，不光是 Vite 本身的知识，也包括 Vite 底层所使用的 Esbuild、Rollup 双引擎、Babel 编译工具链、模块规范标准等一系列构建生态，从此掌握前端构建领域的第一性原理，完成从构建小白到高手的蜕变。</p>\n' +
          '<p>在本课程中，我分了五个部分来系统讲述:</p>\n' +
          '<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94af3f775bd64fbaaaf71d7555f2311d~tplv-k3u1fbpfcp-watermark.image?" alt="深入浅出 Vite (2).png"></p>\n' +
          '<ol>\n' +
          '<li>\n' +
          '<p><strong>基础使用篇。</strong> 重新认识构建工具本身的价值，学会 Vite 基本的功能使用，让你能够独立搭建一个相对完整的脚手架项目。</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p><strong>双引擎篇。</strong> 这个部分我会给你详细介绍 Vite 的双引擎架构，并带你系统学习 Esbuild 和 Rollup 相关的内容，掌握<code>最小必要知识</code>，为后续的高级应用作铺垫。</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p><strong>高级应用篇。</strong> 你将学习到 Vite 的各种高级用法和构建性能优化手段，全程高能实战，每一节都有具体可运行的示例项目。</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p><strong>源码精读篇。</strong> 在这个部分我们将剖析 Vite 的核心源码，理解诸如<code>JIT</code>、<code>Proxy Module</code>、<code>Module Graph</code>、<code>HMR Boundary</code>、<code>Plugin Container</code> 等源码中重要概念的作用及其底层实现。</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p><strong>手写实战篇。</strong> 一方面我们会手写 Vite 的开发时 no-bundle 服务，另一方面也会带你一步步完成一个生产环境打包工具(Bundler)，从 AST 解析的功能开始，最终实现一个 Bundler。</p>\n' +
          '</li>\n' +
          '</ol>\n' +
          '<p>小册最大的特点就是基于实战，理论固然重要，但更重要的是上手实操，几乎所有的知识点你都能找到对应的示例实现代码，在课程的最后一章甚至会手把手教你写一个构建引擎。正如这句话所说:</p>\n' +
          '<blockquote>\n' +
          '<p>Talk is cheap， show me your code.</p>\n' +
          '</blockquote>\n' +
          '<p>希望这本小册能够降低你学习构建工具的门槛，带你真正完成从入门到进阶的过程。虽然本小册并不能解决所有的问题，但我在小册中分享的个人学习经验，以及面对问题时的思维方式或许给你带来一些启发。</p>\n' +
          '<p>祝学习愉快，我们小册中见！</p>\n' +
          '<h2>你会学到什么？</h2>\n' +
          '<ul>\n' +
          '<li>\n' +
          '<p>熟练掌握 Vite 的使用，<code>独立搭建</code>完整的前端工程环境以及工作流；</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>学会 Vite <code>插件开发</code>及项目<code>性能优化</code>技巧，独立解决 Vite 使用过程中的核心难题；</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>深入掌握 Vite 底层用到的打包工具 <code>Esbuild</code> 和 <code>Rollup</code>，学会核心的打包配置和插件开发姿势；</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>彻底理解 Vite 实现原理，学会 Vite 背后的优秀<code>架构思想</code>和<code>核心实现</code>；</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>从 0 到 1 手写构建工具，掌握前端构建工具的原理。</p>\n' +
          '</li>\n' +
          '</ul>\n' +
          '<h2>适宜人群</h2>\n' +
          '<ul>\n' +
          '<li>想要系统学习 Vite，提升竞争力，但没有接触过，也缺少项目经历</li>\n' +
          '<li>想通过 Vite 作为团队或者个人项目的技术栈，但对 Vite 的核心概念和进阶用法一知半解</li>\n' +
          '<li>想系统化学习 Rollup 和 Esbuild，理解构建工具的底层原理及源码实现，苦于学习门槛高</li>\n' +
          '</ul>\n' +
          '<h2>购买须知</h2>\n' +
          '<ol>\n' +
          '<li>本小册为图文形式虚拟内容服务，购买成功概不退款；</li>\n' +
          '<li>小册于 2022 年 04 月 06 日上线，全部章节现已完成更新；</li>\n' +
          '<li>购买用户可享有永久阅读权限，可进入小册微信群，与作者互动；</li>\n' +
          '<li>掘金小册版权归北京北比信息技术有限公司所有，任何机构、媒体、网站或个人未经本网协议授权不得转载、链接、转贴或以其他方式复制发布/发表，违者将依法追究责任；</li>\n' +
          '<li>在掘金小册阅读过程中，如有任何问题，请邮件联系 <a href="mailto:xiaoce@xitu.io">xiaoce@xitu.io</a></li>\n' +
          '</ol>',
        draft_content: '',
        draft_title: '小册介绍',
        markdown_content: '',
        markdown_show: '',
        is_free: 0,
        read_time: 320,
        read_count: 0,
        comment_count: 0,
        ctime: 1641716764,
        mtime: 1641716764,
        is_update: 0,
        draft_read_time: 0,
        vid: '',
        reading_progress: null
      },
      sections: [
        {
          id: 85822,
          section_id: '7050063812044685343',
          title: '开篇 ：让 Vite 助力你的前端工程化之路',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '开篇 ：让 Vite 助力你的前端工程化之路',
          markdown_content: '',
          markdown_show: '',
          is_free: 1,
          read_time: 510,
          read_count: 13485,
          comment_count: 53,
          ctime: 1641716764,
          mtime: 1641716764,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7050063812044685343',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 17,
            has_update: 1,
            last_rtime: 1663479493,
            ctime: 1656236051,
            mtime: 1663479492
          }
        },
        {
          id: 86674,
          section_id: '7077834799208988675',
          title: '模块标准：为什么 ESM 是前端模块化的未来？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '模块标准：为什么 ESM 是前端模块化的未来？',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 1988,
          read_count: 8291,
          comment_count: 37,
          ctime: 1648023179,
          mtime: 1648023179,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7077834799208988675',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 17,
            has_update: 1,
            last_rtime: 1663479116,
            ctime: 1656247440,
            mtime: 1663479276
          }
        },
        {
          id: 85932,
          section_id: '7053634868994899975',
          title: '快速上手: 如何用 Vite 从零搭建前端项目？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '快速上手: 如何用 Vite 从零搭建前端项目？',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 1229,
          read_count: 8436,
          comment_count: 61,
          ctime: 1642328835,
          mtime: 1642328835,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7053634868994899975',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1663414495,
            ctime: 1656247440,
            mtime: 1663414494
          }
        },
        {
          id: 86098,
          section_id: '7057872229589057576',
          title: '样式方案：在 Vite 中接入现代化的 CSS 工程化方案',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '样式方案：在 Vite 中接入现代化的 CSS 工程化方案',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 2084,
          read_count: 8055,
          comment_count: 83,
          ctime: 1643517556,
          mtime: 1643517556,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7057872229589057576',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1663414496,
            ctime: 1656249641,
            mtime: 1663414495
          }
        },
        {
          id: 86100,
          section_id: '7058853948060336163',
          title: '代码规范: 如何利用 Lint 工具链来保证代码风格和质量？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '代码规范: 如何利用 Lint 工具链来保证代码风格和质量？',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 2201,
          read_count: 7528,
          comment_count: 94,
          ctime: 1643539182,
          mtime: 1643539182,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7058853948060336163',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1663414496,
            ctime: 1656249660,
            mtime: 1663414496
          }
        },
        {
          id: 86101,
          section_id: '7058854154738860066',
          title: '静态资源: 如何在 Vite 中处理各种静态资源？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '静态资源: 如何在 Vite 中处理各种静态资源？',
          markdown_content: '',
          markdown_show: '',
          is_free: 1,
          read_time: 2547,
          read_count: 8514,
          comment_count: 60,
          ctime: 1643634078,
          mtime: 1643634078,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7058854154738860066',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1663414497,
            ctime: 1656467574,
            mtime: 1663414496
          }
        },
        {
          id: 86102,
          section_id: '7058947037877764137',
          title: '预构建: 如何玩转秒级依赖预构建的能力？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '预构建: 如何玩转秒级依赖预构建的能力？',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 1265,
          read_count: 5796,
          comment_count: 63,
          ctime: 1643727625,
          mtime: 1643727625,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7058947037877764137',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1663414498,
            ctime: 1656668570,
            mtime: 1663414497
          }
        },
        {
          id: 86113,
          section_id: '7060398408430780431',
          title: '双引擎架构: Vite 是如何站在巨人的肩膀上实现的？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '双引擎架构: Vite 是如何站在巨人的肩膀上实现的？',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 799,
          read_count: 4794,
          comment_count: 37,
          ctime: 1643878668,
          mtime: 1643878668,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7060398408430780431',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1663296029,
            ctime: 1656854321,
            mtime: 1663295639
          }
        },
        {
          id: 86117,
          section_id: '7060405118163746850',
          title: '得力的性能推手: Esbuild 功能使用与插件开发实战',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '得力的性能推手: Esbuild 功能使用与插件开发实战',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 3199,
          read_count: 5126,
          comment_count: 50,
          ctime: 1644047375,
          mtime: 1644047375,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7060405118163746850',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1663297715,
            ctime: 1656856344,
            mtime: 1663297713
          }
        },
        {
          id: 86128,
          section_id: '7061788120680759331',
          title: 'Vite 构建基石(上)——Rollup 打包基本概念及使用',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: 'Vite 构建基石(上)——Rollup 打包基本概念及使用',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 1853,
          read_count: 4183,
          comment_count: 15,
          ctime: 1644216084,
          mtime: 1644216084,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7061788120680759331',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1663297717,
            ctime: 1656856661,
            mtime: 1663297715
          }
        },
        {
          id: 86129,
          section_id: '7061854307863232547',
          title: 'Vite 构建基石(下)——深入理解 Rollup 的插件机制',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: 'Vite 构建基石(下)——深入理解 Rollup 的插件机制',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 2368,
          read_count: 3987,
          comment_count: 26,
          ctime: 1644221068,
          mtime: 1644221068,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7061854307863232547',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1663297721,
            ctime: 1656925341,
            mtime: 1663295587
          }
        },
        {
          id: 86299,
          section_id: '7065976180125466638',
          title: '插件开发与实战: 如何开发一个完整的 Vite 插件？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '插件开发与实战: 如何开发一个完整的 Vite 插件？',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 2912,
          read_count: 3577,
          comment_count: 29,
          ctime: 1645323809,
          mtime: 1645323809,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7065976180125466638',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1663297724,
            ctime: 1656990961,
            mtime: 1663297721
          }
        },
        {
          id: 86298,
          section_id: '7065976180020609032',
          title: 'HMR API 及原理：代码改动后，如何进行毫秒级别的局部更新？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: 'HMR API 及原理：代码改动后，如何进行毫秒级别的局部更新？',
          markdown_content: '',
          markdown_show: '',
          is_free: 1,
          read_time: 1897,
          read_count: 3501,
          comment_count: 15,
          ctime: 1645321442,
          mtime: 1645321442,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7065976180020609032',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1658124913,
            ctime: 1656990965,
            mtime: 1658122644
          }
        },
        {
          id: 86300,
          section_id: '7066601785166659620',
          title: '代码分割：打包完产物体积太大，怎么拆包？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '代码分割：打包完产物体积太大，怎么拆包？',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 2005,
          read_count: 2955,
          comment_count: 29,
          ctime: 1645323882,
          mtime: 1645323882,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7066601785166659620',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 57,
            has_update: 1,
            last_rtime: 1663307890,
            ctime: 1656852612,
            mtime: 1663297724
          }
        },
        {
          id: 86301,
          section_id: '7066611951547187214',
          title: '语法降级与Polyfill：联合前端编译工具链，消灭低版本浏览器兼容问题',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '语法降级与Polyfill：联合前端编译工具链，消灭低版本浏览器兼容问题',
          markdown_content: '',
          markdown_show: '',
          is_free: 1,
          read_time: 2221,
          read_count: 3095,
          comment_count: 38,
          ctime: 1645323993,
          mtime: 1645323993,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7066611951547187214',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1658212839,
            ctime: 1657010153,
            mtime: 1658212830
          }
        },
        {
          id: 86302,
          section_id: '7066612265536978981',
          title: ' 预渲染：如何借助 Vite 搭建高可用的服务端渲染(SSR)工程？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: ' 预渲染：如何借助 Vite 搭建高可用的服务端渲染(SSR)工程？',
          markdown_content: '',
          markdown_show: '',
          is_free: 1,
          read_time: 4085,
          read_count: 2104,
          comment_count: 21,
          ctime: 1645324095,
          mtime: 1645324095,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7066612265536978981',
            reading_end: 0,
            reading_progress: 0,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1658137091,
            ctime: 1658137089,
            mtime: 1658137089
          }
        },
        {
          id: 86369,
          section_id: '7068105121523531806',
          title: '模块联邦: 如何实现优雅的跨应用代码共享？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '模块联邦: 如何实现优雅的跨应用代码共享？',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 2450,
          read_count: 2018,
          comment_count: 27,
          ctime: 1645711673,
          mtime: 1645711673,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7068105121523531806',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 7,
            has_update: 1,
            last_rtime: 1660293640,
            ctime: 1658136482,
            mtime: 1660293221
          }
        },
        {
          id: 86370,
          section_id: '7068105121615314952',
          title: '再谈 ESM：高阶特性 & Pure ESM 时代',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '再谈 ESM：高阶特性 & Pure ESM 时代',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 1543,
          read_count: 1616,
          comment_count: 7,
          ctime: 1645711754,
          mtime: 1645711754,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7068105121615314952',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1658137093,
            ctime: 1658135862,
            mtime: 1658137093
          }
        },
        {
          id: 86303,
          section_id: '7066612739912761352',
          title: '性能优化:  如何体系化地对 Vite 项目进行性能优化？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '性能优化:  如何体系化地对 Vite 项目进行性能优化？',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 1790,
          read_count: 1886,
          comment_count: 8,
          ctime: 1645324159,
          mtime: 1645324159,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7066612739912761352',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 94,
            has_update: 1,
            last_rtime: 1658221145,
            ctime: 1658135858,
            mtime: 1658220178
          }
        },
        {
          id: 86307,
          section_id: '7066614740574797832',
          title: '配置解析服务：配置文件在 Vite 内部被转换成什么样子了？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '配置解析服务：配置文件在 Vite 内部被转换成什么样子了？',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 2223,
          read_count: 1771,
          comment_count: 9,
          ctime: 1645325120,
          mtime: 1645325120,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7066614740574797832',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1663296964,
            ctime: 1658140136,
            mtime: 1663296062
          }
        },
        {
          id: 86309,
          section_id: '7066617580068274207',
          title: '依赖预构建：Esbuild 打包功能如何被 Vite 玩出花来？',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '依赖预构建：Esbuild 打包功能如何被 Vite 玩出花来？',
          markdown_content: '',
          markdown_show: '',
          is_free: 1,
          read_time: 3510,
          read_count: 2914,
          comment_count: 15,
          ctime: 1645325164,
          mtime: 1645325164,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7066617580068274207',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1663297701,
            ctime: 1658210387,
            mtime: 1663296973
          }
        },
        {
          id: 86310,
          section_id: '7066617652487127077',
          title: '插件流水线：从整体到局部，理解 Vite 的核心编译能力',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '插件流水线：从整体到局部，理解 Vite 的核心编译能力',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 4236,
          read_count: 1695,
          comment_count: 3,
          ctime: 1645325174,
          mtime: 1645325174,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: null
        },
        {
          id: 86311,
          section_id: '7066617769776644126',
          title: ' 热更新：基于 ESM 的毫秒级 HMR 的实现揭秘',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: ' 热更新：基于 ESM 的毫秒级 HMR 的实现揭秘',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 3246,
          read_count: 1644,
          comment_count: 5,
          ctime: 1645325199,
          mtime: 1645325199,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7066617769776644126',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1658214504,
            ctime: 1658214196,
            mtime: 1658214196
          }
        },
        {
          id: 86304,
          section_id: '7066613178028785700',
          title: '手写 Vite: 实现 no-bundle 开发服务(上)',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '手写 Vite: 实现 no-bundle 开发服务(上)',
          markdown_content: '',
          markdown_show: '',
          is_free: 1,
          read_time: 5486,
          read_count: 2636,
          comment_count: 35,
          ctime: 1645324441,
          mtime: 1645324441,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: null
        },
        {
          id: 86305,
          section_id: '7066613452235603982',
          title: '手写 Vite: 实现 no-bundle 开发服务(下)',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '手写 Vite: 实现 no-bundle 开发服务(下)',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 5567,
          read_count: 1377,
          comment_count: 10,
          ctime: 1645324459,
          mtime: 1645324459,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7066613452235603982',
            reading_end: 0,
            reading_progress: 0,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1658220176,
            ctime: 1658220174,
            mtime: 1658220174
          }
        },
        {
          id: 86306,
          section_id: '7066614663533821983',
          title: '手写 Bundler:  实现 JavaScript AST 解析器——词法分析、语义分析',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '手写 Bundler:  实现 JavaScript AST 解析器——词法分析、语义分析',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 3103,
          read_count: 1221,
          comment_count: 7,
          ctime: 1645324758,
          mtime: 1645324758,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: null
        },
        {
          id: 86413,
          section_id: '7070419010021490702',
          title: '手写 Bundler: 实现代码打包、 Tree Shaking ',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '手写 Bundler: 实现代码打包、 Tree Shaking ',
          markdown_content: '',
          markdown_show: '',
          is_free: 0,
          read_time: 6312,
          read_count: 1336,
          comment_count: 7,
          ctime: 1646220146,
          mtime: 1646220146,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7070419010021490702',
            reading_end: 0,
            reading_progress: 16,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1658210387,
            ctime: 1657001962,
            mtime: 1658210383
          }
        },
        {
          id: 87553,
          section_id: '7120588458145349640',
          title: '加餐: Vite 3.0 核心更新盘点与分析',
          user_id: '430664257382462',
          booklet_id: '7050063811973218341',
          status: 1,
          content: '',
          draft_content: '',
          draft_title: '加餐: Vite 3.0 核心更新盘点与分析',
          markdown_content: '',
          markdown_show: '',
          is_free: 1,
          read_time: 889,
          read_count: 946,
          comment_count: 2,
          ctime: 1657959737,
          mtime: 1657959737,
          is_update: 0,
          draft_read_time: 0,
          vid: '',
          reading_progress: {
            id: 0,
            booklet_id: '7050063811973218341',
            user_id: '3289337926283534',
            section_id: '7120588458145349640',
            reading_end: 0,
            reading_progress: 100,
            reading_position: 0,
            has_update: 1,
            last_rtime: 1663296973,
            ctime: 1658210346,
            mtime: 1663296969
          }
        }
      ]
    }
  },
  level: 'info',
  label: 'juejin',
  timestamp: '2022-09-18 01:43:25.972 PM'
}
{
  message: {
    err_no: 0,
    err_msg: 'success',
    data: {
      section: {
        id: 85822,
        section_id: '7050063812044685343',
        title: '开篇 ：让 Vite 助力你的前端工程化之路',
        user_id: '430664257382462',
        booklet_id: '7050063811973218341',
        status: 1,
        content: '<p>当下，在项目开发的过程中，前端工程师们越来越离不开构建工具了，可以说<strong>构建工具已经成为了前端工程项目的标配。</strong></p>\n' +
          '<p>不过，如今的前端构建工具可谓<code>乱花渐欲迷人眼</code>，有远古时代的<code>browserify</code>、<code>grunt</code>，有传统的<code>Webpack</code>、<code>Rollup</code>、<code>Parcel</code>，也有现代的<code>Esbuild</code>、<code>Vite</code> 等等，不仅种类繁多，更新也很快。</p>\n' +
          '<p>于是，很多朋友会问我，到底哪个构建工具更好用、值得学。事实上，<strong>无论工具层面如何更新，它们解决的核心问题，即前端工程的痛点是不变的</strong>。因此，想要知道哪个工具更好用，就要看它解决前端工程痛点的效果。</p>\n' +
          '<p>那么，前端工程都有哪些痛点呢？</p>\n' +
          '<p>首先是前端的<strong>模块化需求</strong>。我们知道，业界的模块标准非常多，包括 ESM、CommonJS、AMD 和 CMD 等等。前端工程一方面需要落实这些模块规范，保证模块正常加载。另一方面需要兼容不同的模块规范，以适应不同的执行环境。</p>\n' +
          '<p>其次是<strong>兼容浏览器，编译高级语法</strong>。由于浏览器的实现规范所限，只要高级语言/语法（TypeScript、 JSX 等）想要在浏览器中正常运行，就必须被转化为浏览器可以理解的形式。这都需要工具链层面的支持，而且这个需求会一直存在。</p>\n' +
          '<p>再者是<strong>线上代码的质量</strong>问题。和开发阶段的考虑侧重点不同，生产环境中，我们不仅要考虑代码的<code>安全性</code>、<code>兼容性</code>问题，保证线上代码的正常运行，也需要考虑代码运行时的性能问题。由于浏览器的版本众多，代码兼容性和安全策略各不相同，线上代码的质量问题也将是前端工程中长期存在的一个痛点。</p>\n' +
          '<p>同时，<code>开发效率</code><strong>也不容忽视。</strong> 我们知道，<strong>项目的冷启动/二次启动时间</strong>、<strong>热更新时间</strong>都可能严重影响开发效率，尤其是当项目越来越庞大的时候。因此，提高项目的启动速度和热更新速度也是前端工程的重要需求。</p>\n' +
          '<p>那么，前端构建工具是如何解决以上问题的呢？</p>\n' +
          '<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f54b17dcae4c49adb558b760048c3603~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>\n' +
          '<ul>\n' +
          '<li>\n' +
          '<p>模块化方面，提供模块加载方案，并兼容不同的模块规范。</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>语法转译方面，配合 <code>Sass</code>、<code>TSC</code>、<code>Babel</code> 等前端工具链，完成高级语法的转译功能，同时对于静态资源也能进行处理，使之能作为一个模块正常加载。</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>产物质量方面，在生产环境中，配合 <code>Terser</code>等压缩工具进行代码压缩和混淆，通过 <code>Tree Shaking</code> 删除未使用的代码，提供对于低版本浏览器的语法降级处理等等。</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>开发效率方面，构建工具本身通过各种方式来进行性能优化，包括<code>使用原生语言 Go/Rust</code>、<code>no-bundle</code>等等思路，提高项目的启动性能和热更新的速度。</p>\n' +
          '</li>\n' +
          '</ul>\n' +
          '<h2>为什么 Vite 是当前最高效的构建工具？</h2>\n' +
          '<p>现在，让我们回到一开始提出的问题，到底哪个工具更好用？或者说，哪个工具解决前端工程痛点的效果更好？</p>\n' +
          '<p>The State of JavaScript Survey 最近的调查结果中显示， Vite 在全球开发者中的满意度超过 98%，已经被用到了<code>SvelteKit</code>、<code>Astro</code>这些大型框架中，成为当下最受瞩目的前端构建工具。我也最推荐你使用它。为什么是 Vite 呢？我们可以根据上面说的四个维度来审视它。</p>\n' +
          '<p>首先是开发效率。传统构建工具普遍的缺点就是太慢了，与之相比，Vite 能将项目的启动性能提升一个量级，并且达到毫秒级的瞬间热更新效果。</p>\n' +
          '<p>就拿 Webpack 来说，我在工作中发现，一般的项目使用 Webpack 之后，启动花个几分钟都是很常见的事情，热更新也经常需要等待十秒以上。这主要是因为：</p>\n' +
          '<ul>\n' +
          '<li>项目冷启动时必须递归打包整个项目的依赖树</li>\n' +
          '<li>JavaScript 语言本身的性能限制，导致构建性能遇到瓶颈，直接影响开发效率</li>\n' +
          '</ul>\n' +
          '<p>这样一来，代码改动后不能立马看到效果，自然开发体验也越来越差。而其中，最占用时间的就是代码打包和文件编译。</p>\n' +
          '<p>而 Vite 很好地解决了这些问题。一方面，Vite 在开发阶段基于浏览器原生 ESM 的支持实现了<code>no-bundle</code>服务，另一方面借助 Esbuild 超快的编译速度来做第三方库构建和 TS/JSX 语法编译，从而能够有效提高开发效率。</p>\n' +
          '<p>除了开发效率，在其他三个维度上， Vite 也表现不俗。</p>\n' +
          '<ul>\n' +
          '<li>\n' +
          '<p>模块化方面，Vite 基于浏览器原生 ESM 的支持实现模块加载，并且无论是开发环境还是生产环境，都可以将其他格式的产物(如 CommonJS)转换为 ESM。</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>语法转译方面，Vite 内置了对 TypeScript、JSX、Sass 等高级语法的支持，也能够加载各种各样的静态资源，如图片、Worker 等等。</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>产物质量方面，Vite 基于成熟的打包工具 Rollup 实现生产环境打包，同时可以配合<code>Terser</code>、<code>Babel</code>等工具链，可以极大程度保证构建产物的质量。</p>\n' +
          '</li>\n' +
          '</ul>\n' +
          '<p>因此，如果你想要学习一个前端构建工具，Vite 将会是你当下一个最好的选择。它不仅解决了传统构建工具的开发效率问题，而且具备一个优秀构建工具的各项要素，还经历了社区大规模的验证与落地。</p>\n' +
          '<h2>如何才能学好 Vite ？</h2>\n' +
          '<p>不过，很多人在学习和应用 Vite 的过程中总会遇到各种各样的问题。</p>\n' +
          '<p>比如说，很多 Vite 学习资料既不系统，也不深入。绝大多数的文章只能教会我们如何搭建一个简单的脚手架项目，甚至代码都不一定正确。</p>\n' +
          '<p>即使通过资料学完了 Vite 的相关知识，但因为对 Vite 的生态了解不够，遇到实际问题的时候依然不知道要使用哪些插件或者解决方案。</p>\n' +
          '<ul>\n' +
          '<li>第三方库里面含有 CommonJS 代码导致报错了怎么办?</li>\n' +
          '<li>想在开发过程中进行 Eslint 代码规范检查怎么办？</li>\n' +
          '<li>生产环境打包项目后，如何产出构建产物分析报告？</li>\n' +
          '<li>如果要兼容不支持原生 ESM 的浏览器，怎么办？</li>\n' +
          '</ul>\n' +
          '<p>而且，如果你对 Vite 底层使用的构建引擎 Esbuild 和 Rollup 不够熟悉，遇到一些需要定制的场景，往往也会捉襟见肘。</p>\n' +
          '<ul>\n' +
          '<li>写一个 Esbuild 插件来处理一下问题依赖</li>\n' +
          '<li>对于 Rollup 打包产物进行自定义拆包，解决实际场景中经常出现的循环依赖问题</li>\n' +
          '<li>使用 Esbuild 的代码转译和压缩功能会出现哪些兼容性问题？如何解决？</li>\n' +
          '</ul>\n' +
          '<p>当然，作为一个构建工具，Vite 的难点不仅在于它本身的灵活性，也包含了诸如<code>Babel</code>、<code>core-js</code> 等诸多前端工具链的集成和应用。</p>\n' +
          '<ul>\n' +
          '<li><code>@babel/preset-env</code> 的 <code>useBuiltIns</code> 属性各个取值有哪些区别？</li>\n' +
          '<li><code>@babel/polyfill</code> 与 <code>@babel/runtime-corejs</code> 有什么区别？</li>\n' +
          '<li><code>@babel/plugin-transform-runtime</code> 与<code>@babel/preset-env</code> 的 <code>useBuiltIn</code> 相比有什么优化？</li>\n' +
          '<li>core-js 的作用是什么？其产物有哪些版本？<code>core-js</code> 和 <code>core-js-pure</code> 有什么区别？</li>\n' +
          '</ul>\n' +
          '<p>此外，由于构建工具(不仅包括 Vite，也包括底层引擎 Rollup)的源码晦涩难懂，涉及大量的基础工具库，导致很多人对构建工具原理的理解只浮于表面，很难更进一步。</p>\n' +
          '<p>作为一名深耕在一线的前端工程师，我的日常工作就是跟各种构建工具打交道，在公司中诸多的业务项目中落地了 Vite，有丰富的 Vite 实战经验和源码阅读经验，也给 Vite 仓库贡献过一些代码。因此，我也非常乐意将自己在 Vite 方面的实战经验与学习方法通过小册系统性地分享给大家。</p>\n' +
          '<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/112094547231465195123dabcc084ff8~tplv-k3u1fbpfcp-watermark.image?" alt="20220323稀土掘金-「小册」《深入浅出 Vite 》视觉延展 - 改1_作者简介.jpg"></p>\n' +
          '<p>那么， Vite 该如何学习呢？我按照<strong>循序渐进、可实操、可延伸</strong>的三个原则，由浅入深设计课程内容，提供大量的实战场景和案例，同时尽可能给大家提供解决问题的方法和视角，让大家学完课程后能做到举一反三。具体来说，我将课程设计为 5 个模块。</p>\n' +
          '<p><strong>在基础使用篇中</strong>，我将与你从 0 开始实现 Vite 项目初始化，接入各种现代化的 CSS 方案，集成 Eslint、Styelint、Commonlint 等一系列 Lint 工具链，处理各种形式的静态资源，掌握 Vite 预编译的各种使用技巧，最终让你能独立搭建一个相对完整的脚手架工程。</p>\n' +
          '<p><strong>在双引擎篇中</strong>，我们会学习 Vite 的双引擎架构， Esbuild 和 Rollup 相关的内容，包括它们的基本使用和插件开发，掌握<code>最小必要知识</code>，为后续的高级应用作铺垫。</p>\n' +
          '<p><strong>而高级应用篇</strong>， 我们将学习 Vite 的各种高级用法和构建性能优化手段，学会如何编写一个完整的 Vite 插件，熟练进行生产环境拆包，使用 Vite 搭建复杂的 SSR 工程，实现基于模块联邦的跨应用模块共享架构。不管是项目性能优化技巧，还是对前端底层标准和规范的理解，你都会从这一模块得到不少提升。</p>\n' +
          '<p>接下来，我们将一起剖析 <strong>Vite</strong> <strong>的核心源码</strong>，理解诸如<code>JIT</code>、<code>Proxy Module</code>、<code>Module Graph</code>、<code>HMR Boundary</code>和<code>Plugin Container</code> 等源码中重要概念的作用及底层实现，一步步教你学会阅读 Vite 的源码，将如下架构图中的关键环节各个击破，学透 Vite 实现原理。</p>\n' +
          '<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02910cd2c6894bcdb3a9e0fc9e59f4c2~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>\n' +
          '<p><strong>最后是手写实战篇。</strong> 首先，我们会手写 Vite 的开发时 no-bundle 服务，也就是开发环境下基于浏览器原生 ESM 的 Dev Server。然后，我也会带你一步步完成一个生产环境打包工具（Bundler），从 AST 解析的功能开始，完成代码的词法分析（tokenize）和语义分析（parse），实现模块依赖图和作用域链的搭建，并完成 Tree Shaking、循环依赖检测及 Bundle 代码生成，最终实现一个类似 Rollup 的 Bundler。</p>\n' +
          '<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52599ad0dbb344d59eafb00f360e99c3~tplv-k3u1fbpfcp-watermark.image?" alt="深入浅出 Vite (2).png"></p>\n' +
          '<p>可以看到，我们在课程中非常重视上手实战。课程的代码全部会上传至 Github 仓库(<a href="https://github.com/sanyuan0704/juejin-book-vite" target="_blank" rel="nofollow noopener noreferrer">仓库地址</a>)，基本上每一节内容都有能 run 起来的代码案例。尤其在最后一章，为了让你理解构建工具的底层原理，我会带你一步步搭建一个简单的构建工具，进行上千行代码的手写实战，做到真正的代码可实操。</p>\n' +
          '<p>最后，我希望在这本小册中，我们能一起深入 Vite 的实战要点和实现原理 ，领略前端工程化构建领域的底层风光，真正实现 Vite 从入门到进阶！</p>',
        draft_content: '',
        draft_title: '开篇 ：让 Vite 助力你的前端工程化之路',
        markdown_content: '',
        markdown_show: '当下，在项目开发的过程中，前端工程师们越来越离不开构建工具了，可以说**构建工具已经成为了前端工程项目的标配。**\n' +
          '\n' +
          '不过，如今的前端构建工具可谓`乱花渐欲迷人眼`，有远古时代的`browserify`、`grunt`，有传统的`Webpack`、`Rollup`、`Parcel`，也有现代的`Esbuild`、`Vite` 等等，不仅种类繁多，更新也很快。\n' +
          '\n' +
          '于是，很多朋友会问我，到底哪个构建工具更好用、值得学。事实上，**无论工具层面如何更新，它们解决的核心问题，即前端工程的痛点是不变的**。因此，想要知道哪个工具更好用，就要看它解决前端工程痛点的效果。\n' +
          '\n' +
          '那么，前端工程都有哪些痛点呢？\n' +
          '\n' +
          '首先是前端的**模块化需求**。我们知道，业界的模块标准非常多，包括 ESM、CommonJS、AMD 和 CMD 等等。前端工程一方面需要落实这些模块规范，保证模块正常加载。另一方面需要兼容不同的模块规范，以适应不同的执行环境。\n' +
          '\n' +
          '其次是**兼容浏览器，编译高级语法**。由于浏览器的实现规范所限，只要高级语言/语法（TypeScript、 JSX 等）想要在浏览器中正常运行，就必须被转化为浏览器可以理解的形式。这都需要工具链层面的支持，而且这个需求会一直存在。\n' +
          '\n' +
          '再者是**线上代码的质量**问题。和开发阶段的考虑侧重点不同，生产环境中，我们不仅要考虑代码的`安全性`、`兼容性`问题，保证线上代码的正常运行，也需要考虑代码运行时的性能问题。由于浏览器的版本众多，代码兼容性和安全策略各不相同，线上代码的质量问题也将是前端工程中长期存在的一个痛点。\n' +
          '\n' +
          '同时，`开发效率`**也不容忽视。** 我们知道，**项目的冷启动/二次启动时间**、**热更新时间**都可能严重影响开发效率，尤其是当项目越来越庞大的时候。因此，提高项目的启动速度和热更新速度也是前端工程的重要需求。\n' +
          '\n' +
          '那么，前端构建工具是如何解决以上问题的呢？\n' +
          '\n' +
          '![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f54b17dcae4c49adb558b760048c3603~tplv-k3u1fbpfcp-zoom-1.image)\n' +
          '\n' +
          '-   模块化方面，提供模块加载方案，并兼容不同的模块规范。\n' +
          '\n' +
          '\n' +
          '\n' +
          '-   语法转译方面，配合 `Sass`、`TSC`、`Babel` 等前端工具链，完成高级语法的转译功能，同时对于静态资源也能进行处理，使之能作为一个模块正常加载。\n' +
          '\n' +
          '\n' +
          '\n' +
          '-   产物质量方面，在生产环境中，配合 `Terser`等压缩工具进行代码压缩和混淆，通过 `Tree Shaking` 删除未使用的代码，提供对于低版本浏览器的语法降级处理等等。\n' +
          '\n' +
          '\n' +
          '\n' +
          '-   开发效率方面，构建工具本身通过各种方式来进行性能优化，包括`使用原生语言 Go/Rust`、`no-bundle`等等思路，提高项目的启动性能和热更新的速度。\n' +
          '\n' +
          '## 为什么 Vite 是当前最高效的构建工具？\n' +
          '\n' +
          '现在，让我们回到一开始提出的问题，到底哪个工具更好用？或者说，哪个工具解决前端工程痛点的效果更好？\n' +
          '\n' +
          'The State of JavaScript Survey 最近的调查结果中显示， Vite 在全球开发者中的满意度超过 98%，已经被用到了`SvelteKit`、`Astro`这些大型框架中，成为当下最受瞩目的前端构建工具。我也最推荐你使用它。为什么是 Vite 呢？我们可以根据上面说的四个维度来审视它。\n' +
          '\n' +
          '首先是开发效率。传统构建工具普遍的缺点就是太慢了，与之相比，Vite 能将项目的启动性能提升一个量级，并且达到毫秒级的瞬间热更新效果。\n' +
          '\n' +
          '就拿 Webpack 来说，我在工作中发现，一般的项目使用 Webpack 之后，启动花个几分钟都是很常见的事情，热更新也经常需要等待十秒以上。这主要是因为：\n' +
          '\n' +
          '-   项目冷启动时必须递归打包整个项目的依赖树\n' +
          '-   JavaScript 语言本身的性能限制，导致构建性能遇到瓶颈，直接影响开发效率\n' +
          '\n' +
          '这样一来，代码改动后不能立马看到效果，自然开发体验也越来越差。而其中，最占用时间的就是代码打包和文件编译。\n' +
          '\n' +
          '而 Vite 很好地解决了这些问题。一方面，Vite 在开发阶段基于浏览器原生 ESM 的支持实现了`no-bundle`服务，另一方面借助 Esbuild 超快的编译速度来做第三方库构建和 TS/JSX 语法编译，从而能够有效提高开发效率。\n' +
          '\n' +
          '除了开发效率，在其他三个维度上， Vite 也表现不俗。\n' +
          '\n' +
          '-   模块化方面，Vite 基于浏览器原生 ESM 的支持实现模块加载，并且无论是开发环境还是生产环境，都可以将其他格式的产物(如 CommonJS)转换为 ESM。\n' +
          '\n' +
          '-   语法转译方面，Vite 内置了对 TypeScript、JSX、Sass 等高级语法的支持，也能够加载各种各样的静态资源，如图片、Worker 等等。\n' +
          '\n' +
          '-   产物质量方面，Vite 基于成熟的打包工具 Rollup 实现生产环境打包，同时可以配合`Terser`、`Babel`等工具链，可以极大程度保证构建产物的质量。\n' +
          '\n' +
          '因此，如果你想要学习一个前端构建工具，Vite 将会是你当下一个最好的选择。它不仅解决了传统构建工具的开发效率问题，而且具备一个优秀构建工具的各项要素，还经历了社区大规模的验证与落地。\n' +
          '\n' +
          '## 如何才能学好 Vite ？\n' +
          '\n' +
          '不过，很多人在学习和应用 Vite 的过程中总会遇到各种各样的问题。\n' +
          '\n' +
          '比如说，很多 Vite 学习资料既不系统，也不深入。绝大多数的文章只能教会我们如何搭建一个简单的脚手架项目，甚至代码都不一定正确。\n' +
          '\n' +
          '即使通过资料学完了 Vite 的相关知识，但因为对 Vite 的生态了解不够，遇到实际问题的时候依然不知道要使用哪些插件或者解决方案。\n' +
          '\n' +
          '-   第三方库里面含有 CommonJS 代码导致报错了怎么办?\n' +
          '-   想在开发过程中进行 Eslint 代码规范检查怎么办？\n' +
          '-   生产环境打包项目后，如何产出构建产物分析报告？\n' +
          '-   如果要兼容不支持原生 ESM 的浏览器，怎么办？\n' +
          '\n' +
          '而且，如果你对 Vite 底层使用的构建引擎 Esbuild 和 Rollup 不够熟悉，遇到一些需要定制的场景，往往也会捉襟见肘。\n' +
          '\n' +
          '-   写一个 Esbuild 插件来处理一下问题依赖\n' +
          '-   对于 Rollup 打包产物进行自定义拆包，解决实际场景中经常出现的循环依赖问题\n' +
          '-   使用 Esbuild 的代码转译和压缩功能会出现哪些兼容性问题？如何解决？\n' +
          '\n' +
          '当然，作为一个构建工具，Vite 的难点不仅在于它本身的灵活性，也包含了诸如`Babel`、`core-js` 等诸多前端工具链的集成和应用。\n' +
          '\n' +
          '-   `@babel/preset-env` 的 `useBuiltIns` 属性各个取值有哪些区别？\n' +
          '-   `@babel/polyfill` 与 `@babel/runtime-corejs` 有什么区别？\n' +
          '-   `@babel/plugin-transform-runtime` 与`@babel/preset-env` 的 `useBuiltIn` 相比有什么优化？\n' +
          '-   core-js 的作用是什么？其产物有哪些版本？`core-js` 和 `core-js-pure` 有什么区别？\n' +
          '\n' +
          '此外，由于构建工具(不仅包括 Vite，也包括底层引擎 Rollup)的源码晦涩难懂，涉及大量的基础工具库，导致很多人对构建工具原理的理解只浮于表面，很难更进一步。\n' +
          '\n' +
          '作为一名深耕在一线的前端工程师，我的日常工作就是跟各种构建工具打交道，在公司中诸多的业务项目中落地了 Vite，有丰富的 Vite 实战经验和源码阅读经验，也给 Vite 仓库贡献过一些代码。因此，我也非常乐意将自己在 Vite 方面的实战经验与学习方法通过小册系统性地分享给大家。\n' +
          '\n' +
          '\n' +
          '![20220323稀土掘金-「小册」《深入浅出 Vite 》视觉延展 - 改1_作者简介.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/112094547231465195123dabcc084ff8~tplv-k3u1fbpfcp-watermark.image?)\n' +
          '\n' +
          '\n' +
          '那么， Vite 该如何学习呢？我按照**循序渐进、可实操、可延伸**的三个原则，由浅入深设计课程内容，提供大量的实战场景和案例，同时尽可能给大家提供解决问题的方法和视角，让大家学完课程后能做到举一反三。具体来说，我将课程设计为 5 个模块。\n' +
          '\n' +
          '**在基础使用篇中**，我将与你从 0 开始实现 Vite 项目初始化，接入各种现代化的 CSS 方案，集成 Eslint、Styelint、Commonlint 等一系列 Lint 工具链，处理各种形式的静态资源，掌握 Vite 预编译的各种使用技巧，最终让你能独立搭建一个相对完整的脚手架工程。\n' +
          '\n' +
          '**在双引擎篇中**，我们会学习 Vite 的双引擎架构， Esbuild 和 Rollup 相关的内容，包括它们的基本使用和插件开发，掌握`最小必要知识`，为后续的高级应用作铺垫。\n' +
          '\n' +
          '**而高级应用篇**， 我们将学习 Vite 的各种高级用法和构建性能优化手段，学会如何编写一个完整的 Vite 插件，熟练进行生产环境拆包，使用 Vite 搭建复杂的 SSR 工程，实现基于模块联邦的跨应用模块共享架构。不管是项目性能优化技巧，还是对前端底层标准和规范的理解，你都会从这一模块得到不少提升。\n' +
          '\n' +
          '接下来，我们将一起剖析 **Vite** **的核心源码**，理解诸如`JIT`、`Proxy Module`、`Module Graph`、`HMR Boundary`和`Plugin Container` 等源码中重要概念的作用及底层实现，一步步教你学会阅读 Vite 的源码，将如下架构图中的关键环节各个击破，学透 Vite 实现原理。\n' +
          '\n' +
          '![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02910cd2c6894bcdb3a9e0fc9e59f4c2~tplv-k3u1fbpfcp-watermark.image?)\n' +
          '\n' +
          '**最后是手写实战篇。** 首先，我们会手写 Vite 的开发时 no-bundle 服务，也就是开发环境下基于浏览器原生 ESM 的 Dev Server。然后，我也会带你一步步完成一个生产环境打包工具（Bundler），从 AST 解析的功能开始，完成代码的词法分析（tokenize）和语义分析（parse），实现模块依赖图和作用域链的搭建，并完成 Tree Shaking、循环依赖检测及 Bundle 代码生成，最终实现一个类似 Rollup 的 Bundler。\n' +
          '\n' +
          '\n' +
          '![深入浅出 Vite (2).png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52599ad0dbb344d59eafb00f360e99c3~tplv-k3u1fbpfcp-watermark.image?)\n' +
          '\n' +
          '可以看到，我们在课程中非常重视上手实战。课程的代码全部会上传至 Github 仓库([仓库地址](https://github.com/sanyuan0704/juejin-book-vite))，基本上每一节内容都有能 run 起来的代码案例。尤其在最后一章，为了让你理解构建工具的底层原理，我会带你一步步搭建一个简单的构建工具，进行上千行代码的手写实战，做到真正的代码可实操。\n' +
          '\n' +
          '最后，我希望在这本小册中，我们能一起深入 Vite 的实战要点和实现原理 ，领略前端工程化构建领域的底层风光，真正实现 Vite 从入门到进阶！\n' +
          '\n' +
          '\n' +
          '\n',
        is_free: 1,
        read_time: 510,
        read_count: 13485,
        comment_count: 53,
        ctime: 1641716764,
        mtime: 1641716764,
        is_update: 0,
        draft_read_time: 510,
        vid: '',
        reading_progress: {
          id: 0,
          booklet_id: '7050063811973218341',
          user_id: '3289337926283534',
          section_id: '7050063812044685343',
          reading_end: 0,
          reading_progress: 100,
          reading_position: 17,
          has_update: 1,
          last_rtime: 1663479493,
          ctime: 1656236051,
          mtime: 1663479492
        }
      }
    }
  },
  level: 'info',
  label: 'juejin',
  timestamp: '2022-09-18 01:43:26.252 PM'
}
{
  message: {
    err_no: 0,
    err_msg: 'success',
    data: {
      section: {
        id: 86100,
        section_id: '7058853948060336163',
        title: '代码规范: 如何利用 Lint 工具链来保证代码风格和质量？',
        user_id: '430664257382462',
        booklet_id: '7050063811973218341',
        status: 1,
        content: '<p>在上一节的内容中，我们详细讲解了如何在 Vite 中实现 CSS 工程化方案，迈出了搭建脚手架项目的第一步。本节，让我们把目光投向项目中另外一个非常重要的部分——<strong>代码规范</strong>。</p>\n' +
          '<blockquote>\n' +
          '<p>代码不仅是让机器看的，它也是给人看的。</p>\n' +
          '</blockquote>\n' +
          '<p>在真实的工程项目中，尤其是多人协作的场景下，代码规范就变得非常重要了，它可以用来统一团队代码风格，避免不同风格的代码混杂到一起难以阅读，有效提高<strong>代码质量</strong>，甚至可以将一些<strong>语法错误</strong>在开发阶段提前规避掉。但仅有规范本身不够，我们需要<strong>自动化的工具</strong>(即<code>Lint 工具</code>)来保证规范的落地，把代码规范检查(包括<code>自动修复</code>)这件事情交给机器完成，开发者只需要专注应用逻辑本身。</p>\n' +
          '<p>本节，我们将一起来完成 Lint 工具链在项目中的落地，实现自动化代码规范检查及修复的能力。学完本节内容后，你不仅能熟悉诸如<code>ESLint</code>、<code>Prettier</code>、<code>Stylelint</code>和<code>Commitlint</code> 等诸多主流 Lint 工具的概念和使用，还能配合<code>husky</code>、<code>lint-staged</code>、<code>VSCode 插件</code>和<code>Vite 生态</code>在项目中集成完整的 Lint 工具链，搭建起完整的前端开发和代码提交工作流，这部分内容虽然和 Vite 没有直接的联系，但也是 Vite 项目搭建中非常重要的一环，是前端工程化的必备知识。</p>\n' +
          '<blockquote>\n' +
          '<p>小节示例项目仓库: <a href="https://github.com/sanyuan0704/juejin-book-vite/tree/main/4~7-vite-project-framework" target="_blank" rel="nofollow noopener noreferrer">点击直达</a></p>\n' +
          '</blockquote>\n' +
          '<h2>JS/TS 规范工具: ESLint</h2>\n' +
          '<h3>简介</h3>\n' +
          '<blockquote>\n' +
          '<p>ESLint 是在 ECMAScript/JavaScript 代码中识别和报告模式匹配的工具，它的目标是保证代码的一致性和避免错误。</p>\n' +
          '</blockquote>\n' +
          '<p>Eslint 是国外的前端大牛<code>Nicholas C. Zakas</code>在 2013 年发起的一个开源项目，有一本书被誉为前端界的"圣经"，叫《JavaScript 高级程序设计》(即红宝书)，他正是这本书的作者。</p>\n' +
          '<p><code>Nicholas</code> 当初做这个开源项目，就是为了打造一款插件化的 JavaScript 代码静态检查工具，通过解析代码的 AST 来分析代码格式，检查代码的风格和质量问题。现在，Eslint 已经成为一个非常成功的开源项目了，基本上属于前端项目中 Lint 工具的标配。</p>\n' +
          '<p>ESLint 的使用并不复杂，主要通过配置文件对各种代码格式的规则(<code>rules</code>)进行配置，以指定具体的代码规范。目前开源社区也有一些成熟的规范集可供使用，著名的包括<a href="https://github.com/airbnb/javascript" target="_blank" rel="nofollow noopener noreferrer">Airbnb JavaScript 代码规范</a>、<a href="https://github.com/standard/standard/blob/master/docs/README-zhcn.md" target="_blank" rel="nofollow noopener noreferrer">Standard JavaScript 规范</a>、<a href="https://google.github.io/styleguide/jsguide.html" target="_blank" rel="nofollow noopener noreferrer">Google JavaScript 规范</a>等等，你可以在项目中直接使用这些成熟的规范，也可以自己定制一套团队独有的代码规范，这在一些大型团队当中还是很常见的。</p>\n' +
          '<h3>初始化</h3>\n' +
          '<p>接下来我们来利用 ESLint 官方的 cli 在现有的脚手架项目中进行初始化操作，首先我们需要安装 ESLint:</p>\n' +
          '<pre><code class="hljs language-bash">pnpm i eslint -D\n' +
          '</code></pre>\n' +
          '<p>接着执行 ESLint 的初始化命令，并进行如下的命令行交互:</p>\n' +
          '<pre><code class="hljs language-ts">npx eslint --init\n' +
          '</code></pre>\n' +
          '<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c71cb725150d4e5c9d46539916047ef1~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>\n' +
          '<p>接着 ESLint 会帮我们自动生成<code>.eslintrc.js</code>配置文件。需要注意的是，在上述初始化流程中我们并没有用 npm 安装依赖，需要进行手动安装:</p>\n' +
          '<pre><code class="hljs language-bash">pnpm i eslint-plugin-react@latest @typescript-eslint/eslint-plugin@latest @typescript-eslint/parser@latest -D\n' +
          '</code></pre>\n' +
          '<h3>核心配置解读</h3>\n' +
          '<p>大家初次接触配置文件可能会有点不太理解，接下来我来为你介绍一下几个核心的配置项，你可以对照目前生成的<code>.eslintrc.js</code>一起学习。</p>\n' +
          '<h4>1. parser - 解析器</h4>\n' +
          '<p>ESLint 底层默认使用 <a href="https://github.com/eslint/espree" target="_blank" rel="nofollow noopener noreferrer">Espree</a>来进行 AST 解析，这个解析器目前已经基于 <code>Acron</code> 来实现，虽然说 <code>Acron</code> 目前能够解析绝大多数的 <a href="https://github.com/acornjs/acorn/tree/master/acorn" target="_blank" rel="nofollow noopener noreferrer">ECMAScript 规范的语法</a>，但还是不支持 TypeScript ，因此需要引入其他的解析器完成 TS 的解析。</p>\n' +
          '<p>社区提供了<code>@typescript-eslint/parser</code>这个解决方案，专门为了 TypeScript 的解析而诞生，将 <code>TS</code> 代码转换为 <code>Espree</code> 能够识别的格式(即 <a href="https://github.com/estree/estree" target="_blank" rel="nofollow noopener noreferrer"><strong>Estree 格式</strong></a>)，然后在 Eslint 下通过<code>Espree</code>进行格式检查， 以此兼容了 TypeScript 语法。</p>\n' +
          '<h4>2. parserOptions  - 解析器选项</h4>\n' +
          '<p>这个配置可以对上述的解析器进行能力定制，默认情况下 ESLint 支持 ES5 语法，你可以配置这个选项，具体内容如下:</p>\n' +
          '<ul>\n' +
          '<li>ecmaVersion: 这个配置和 <code>Acron</code> 的 <a href="https://github.com/acornjs/acorn/tree/master/acorn" target="_blank" rel="nofollow noopener noreferrer">ecmaVersion</a> 是兼容的，可以配置 <code>ES + 数字</code>(如 ES6)或者<code>ES + 年份</code>(如 ES2015)，也可以直接配置为<code>latest</code>，启用最新的 ES 语法。</li>\n' +
          '<li>sourceType: 默认为<code>script</code>，如果使用 ES Module 则应设置为<code>module</code></li>\n' +
          '<li>ecmaFeatures: 为一个对象，表示想使用的额外语言特性，如开启 <code>jsx</code>。</li>\n' +
          '</ul>\n' +
          '<h4>3. rules - 具体代码规则</h4>\n' +
          '<p><code>rules</code> 配置即代表在 ESLint 中手动调整哪些代码规则，比如<code>禁止在 if 语句中使用赋值语句</code>这条规则可以像如下的方式配置:</p>\n' +
          '<pre><code class="hljs language-ts"><span class="hljs-comment">// .eslintrc.js</span>\n' +
          '<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n' +
          '  <span class="hljs-comment">// 其它配置省略</span>\n' +
          '  <span class="hljs-attr">rules</span>: {\n' +
          '    <span class="hljs-comment">// key 为规则名，value 配置内容</span>\n' +
          '    <span class="hljs-string">"no-cond-assign"</span>: [<span class="hljs-string">"error"</span>, <span class="hljs-string">"always"</span>]\n' +
          '  }\n' +
          '}\n' +
          '</code></pre>\n' +
          '<p>在 rules 对象中，<code>key</code> 一般为<code>规则名</code>，<code>value</code> 为具体的配置内容，在上述的例子中我们设置为一个数组，数组第一项为规则的 <code>ID</code>，第二项为<code>规则的配置</code>。</p>\n' +
          '<p>这里重点说一说规则的 ID，它的语法对所有规则都适用，你可以设置以下的值:</p>\n' +
          '<ul>\n' +
          '<li><code>off</code> 或 <code>0</code>: 表示关闭规则。</li>\n' +
          '<li><code>warn</code> 或 <code>1</code>: 表示开启规则，不过违背规则后只抛出 warning，而不会导致程序退出。</li>\n' +
          '<li><code>error</code> 或 <code>2</code>: 表示开启规则，不过违背规则后抛出 error，程序会退出。</li>\n' +
          '</ul>\n' +
          '<p>具体的规则配置可能会不一样，有的是一个字符串，有的可以配置一个对象，你可以参考 <a href="https://cn.eslint.org/docs/rules/" target="_blank" rel="nofollow noopener noreferrer">ESLint 官方文档</a>。</p>\n' +
          '<p>当然，你也能直接将 <code>rules</code> 对象的 <code>value</code> 配置成 ID，如: <code>"no-cond-assign": "error"</code>。</p>\n' +
          '<h4>4. plugins</h4>\n' +
          '<p>上面提到过 ESLint 的 parser 基于<code>Acorn</code>实现，不能直接解析 TypeScript，需要我们指定 parser 选项为<code>@typescript-eslint/parser</code>才能兼容 TS 的解析。同理，ESLint 本身也没有内置 TypeScript 的代码规则，这个时候 ESLint 的插件系统就派上用场了。我们需要通过添加 ESLint 插件来增加一些特定的规则，比如添加<code>@typescript-eslint/eslint-plugin</code> 来拓展一些关于 TS 代码的规则，如下代码所示:</p>\n' +
          '<pre><code class="hljs language-js"><span class="hljs-comment">// .eslintrc.js</span>\n' +
          '<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n' +
          '  <span class="hljs-comment">// 添加 TS 规则，可省略`eslint-plugin`</span>\n' +
          `  <span class="hljs-attr">plugins</span>: [<span class="hljs-string">'@typescript-eslint'</span>]\n` +
          '}\n' +
          '</code></pre>\n' +
          '<p>值得注意的是，添加插件后只是拓展了 ESLint 本身的规则集，但 ESLint 默认并<strong>没有开启</strong>这些规则的校验！如果要开启或者调整这些规则，你需要在 rules 中进行配置，如:</p>\n' +
          '<pre><code class="hljs language-js"><span class="hljs-comment">// .eslintrc.js</span>\n' +
          '<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n' +
          '  <span class="hljs-comment">// 开启一些 TS 规则</span>\n' +
          '  <span class="hljs-attr">rules</span>: {\n' +
          `    <span class="hljs-string">'@typescript-eslint/ban-ts-comment'</span>: <span class="hljs-string">'error'</span>,\n` +
          `    <span class="hljs-string">'@typescript-eslint/no-explicit-any'</span>: <span class="hljs-string">'warn'</span>,\n` +
          '  }\n' +
          '}\n' +
          '</code></pre>\n' +
          '<h4>5. extends - 继承配置</h4>\n' +
          '<p>extends 相当于<code>继承</code>另外一份 ESLint 配置，可以配置为一个字符串，也可以配置成一个字符串数组。主要分如下 3 种情况:</p>\n' +
          '<ol>\n' +
          '<li>从 ESLint 本身继承；</li>\n' +
          '<li>从类似 <code>eslint-config-xxx</code> 的 npm 包继承；</li>\n' +
          '<li>从 ESLint 插件继承。</li>\n' +
          '</ol>\n' +
          '<pre><code class="hljs language-ts"><span class="hljs-comment">// .eslintrc.js</span>\n' +
          '<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n' +
          '   <span class="hljs-string">"extends"</span>: [\n' +
          '     <span class="hljs-comment">// 第1种情况 </span>\n' +
          '     <span class="hljs-string">"eslint:recommended"</span>,\n' +
          '     <span class="hljs-comment">// 第2种情况，一般配置的时候可以省略 `eslint-config`</span>\n' +
          '     <span class="hljs-string">"standard"</span>\n' +
          '     <span class="hljs-comment">// 第3种情况，可以省略包名中的 `eslint-plugin`</span>\n' +
          '     <span class="hljs-comment">// 格式一般为: `plugin:${pluginName}/${configName}`</span>\n' +
          '     <span class="hljs-string">"plugin:react/recommended"</span>\n' +
          '     <span class="hljs-string">"plugin:@typescript-eslint/recommended"</span>,\n' +
          '   ]\n' +
          '}\n' +
          '</code></pre>\n' +
          '<p>有了 extends 的配置，对于之前所说的 ESLint 插件中的繁多配置，我们就<strong>不需要手动一一开启</strong>了，通过 extends 字段即可自动开启插件中的推荐规则:</p>\n' +
          '<pre><code class="hljs language-js"><span class="hljs-attr">extends</span>: [<span class="hljs-string">"plugin:@typescript-eslint/recommended"</span>]\n' +
          '</code></pre>\n' +
          '<h4>6. env 和 globals</h4>\n' +
          '<p>这两个配置分别表示<code>运行环境</code>和<code>全局变量</code>，在指定的运行环境中会预设一些全局变量，比如:</p>\n' +
          '<pre><code class="hljs language-js"><span class="hljs-comment">// .eslint.js</span>\n' +
          '<span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span> = {\n' +
          '  <span class="hljs-string">"env"</span>: {\n' +
          '    <span class="hljs-string">"browser"</span>: <span class="hljs-string">"true"</span>,\n' +
          '    <span class="hljs-string">"node"</span>: <span class="hljs-string">"true"</span>\n' +
          '  }\n' +
          '}\n' +
          '</code></pre>\n' +
          '<p>指定上述的 <code>env</code> 配置后便会启用浏览器和 Node.js 环境，这两个环境中的一些全局变量(如 <code>window</code>、<code>global</code> 等)会同时启用。</p>\n' +
          '<p>有些全局变量是业务代码引入的第三方库所声明，这里就需要在<code>globals</code>配置中声明全局变量了。每个全局变量的配置值有 3 种情况:</p>\n' +
          '<ol>\n' +
          '<li><code>"writable"</code>或者 <code>true</code>，表示变量可重写；</li>\n' +
          '<li><code>"readonly"</code>或者<code>false</code>，表示变量不可重写；</li>\n' +
          '<li><code>"off"</code>，表示禁用该全局变量。</li>\n' +
          '</ol>\n' +
          '<p>那<code>jquery</code>举例，我们可以在配置文件中声明如下:</p>\n' +
          '<pre><code class="hljs language-js"><span class="hljs-comment">// .eslintrc.js</span>\n' +
          '<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n' +
          '  <span class="hljs-string">"globals"</span>: {\n' +
          '    <span class="hljs-comment">// 不可重写</span>\n' +
          '    <span class="hljs-string">"$"</span>: <span class="hljs-literal">false</span>, \n' +
          '    <span class="hljs-string">"jQuery"</span>: <span class="hljs-literal">false</span> \n' +
          '  }\n' +
          '}\n' +
          '</code></pre>\n' +
          '<p>相信有了上述核心配置部分的讲解，你再回头看看初始化生成的 ESLint 配置文件，你也能很好地理解各个配置项的含义了。</p>\n' +
          '<h3>与 Prettier 强强联合</h3>\n' +
          '<p>虽然 ESLint 本身具备自动格式化代码的功能(<code>eslint --fix</code>)，但术业有专攻，ESLint 的主要优势在于<code>代码的风格检查并给出提示</code>，而在代码格式化这一块 Prettier 做的更加专业，因此我们经常将 ESLint 结合 Prettier 一起使用。</p>\n' +
          '<p>首先我们来安装一下 Prettier:</p>\n' +
          '<pre><code class="hljs language-ts">pnpm i prettier -D\n' +
          '</code></pre>\n' +
          '<p>在项目根目录新建<code>.prettierrc.js</code>配置文件，填写如下的配置内容:</p>\n' +
          '<pre><code class="hljs language-js"><span class="hljs-comment">// .prettierrc.js</span>\n' +
          '<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n' +
          '  <span class="hljs-att'... 16417 more characters,
        draft_content: '',
        draft_title: '代码规范: 如何利用 Lint 工具链来保证代码风格和质量？',
        markdown_content: '',
        markdown_show: '在上一节的内容中，我们详细讲解了如何在 Vite 中实现 CSS 工程化方案，迈出了搭建脚手架项目的第一步。本节，让我们把目光投向项目中另外一个非常重要的部分——**代码规范**。\n' +
          '\n' +
          '> 代码不仅是让机器看的，它也是给人看的。\n' +
          '\n' +
          '在真实的工程项目中，尤其是多人协作的场景下，代码规范就变得非常重要了，它可以用来统一团队代码风格，避免不同风格的代码混杂到一起难以阅读，有效提高**代码质量**，甚至可以将一些**语法错误**在开发阶段提前规避掉。但仅有规范本身不够，我们需要**自动化的工具**(即`Lint 工具`)来保证规范的落地，把代码规范检查(包括`自动修复`)这件事情交给机器完成，开发者只需要专注应用逻辑本身。\n' +
          '\n' +
          '本节，我们将一起来完成 Lint 工具链在项目中的落地，实现自动化代码规范检查及修复的能力。学完本节内容后，你不仅能熟悉诸如`ESLint`、`Prettier`、`Stylelint`和`Commitlint` 等诸多主流 Lint 工具的概念和使用，还能配合`husky`、`lint-staged`、`VSCode 插件`和`Vite 生态`在项目中集成完整的 Lint 工具链，搭建起完整的前端开发和代码提交工作流，这部分内容虽然和 Vite 没有直接的联系，但也是 Vite 项目搭建中非常重要的一环，是前端工程化的必备知识。\n' +
          '\n' +
          '> 小节示例项目仓库: [点击直达](https://github.com/sanyuan0704/juejin-book-vite/tree/main/4~7-vite-project-framework)\n' +
          '\n' +
          '## JS/TS 规范工具: ESLint \n' +
          '### 简介\n' +
          '> ESLint 是在 ECMAScript/JavaScript 代码中识别和报告模式匹配的工具，它的目标是保证代码的一致性和避免错误。\n' +
          '\n' +
          'Eslint 是国外的前端大牛`Nicholas C. Zakas`在 2013 年发起的一个开源项目，有一本书被誉为前端界的"圣经"，叫《JavaScript 高级程序设计》(即红宝书)，他正是这本书的作者。\n' +
          '\n' +
          '`Nicholas` 当初做这个开源项目，就是为了打造一款插件化的 JavaScript 代码静态检查工具，通过解析代码的 AST 来分析代码格式，检查代码的风格和质量问题。现在，Eslint 已经成为一个非常成功的开源项目了，基本上属于前端项目中 Lint 工具的标配。\n' +
          '\n' +
          'ESLint 的使用并不复杂，主要通过配置文件对各种代码格式的规则(`rules`)进行配置，以指定具体的代码规范。目前开源社区也有一些成熟的规范集可供使用，著名的包括[Airbnb JavaScript 代码规范](https://github.com/airbnb/javascript)、[Standard JavaScript 规范](https://github.com/standard/standard/blob/master/docs/README-zhcn.md)、[Google JavaScript 规范](https://google.github.io/styleguide/jsguide.html)等等，你可以在项目中直接使用这些成熟的规范，也可以自己定制一套团队独有的代码规范，这在一些大型团队当中还是很常见的。\n' +
          '\n' +
          '### 初始化\n' +
          '接下来我们来利用 ESLint 官方的 cli 在现有的脚手架项目中进行初始化操作，首先我们需要安装 ESLint:\n' +
          '```bash\n' +
          'pnpm i eslint -D\n' +
          '```\n' +
          '\n' +
          '接着执行 ESLint 的初始化命令，并进行如下的命令行交互:\n' +
          '```ts\n' +
          'npx eslint --init\n' +
          '```\n' +
          '![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c71cb725150d4e5c9d46539916047ef1~tplv-k3u1fbpfcp-watermark.image?)\n' +
          '\n' +
          '接着 ESLint 会帮我们自动生成`.eslintrc.js`配置文件。需要注意的是，在上述初始化流程中我们并没有用 npm 安装依赖，需要进行手动安装:\n' +
          '```bash\n' +
          'pnpm i eslint-plugin-react@latest @typescript-eslint/eslint-plugin@latest @typescript-eslint/parser@latest -D\n' +
          '```\n' +
          '\n' +
          '### 核心配置解读\n' +
          '大家初次接触配置文件可能会有点不太理解，接下来我来为你介绍一下几个核心的配置项，你可以对照目前生成的`.eslintrc.js`一起学习。\n' +
          '\n' +
          '#### 1. parser - 解析器\n' +
          'ESLint 底层默认使用 [Espree](https://github.com/eslint/espree)来进行 AST 解析，这个解析器目前已经基于 `Acron` 来实现，虽然说 `Acron` 目前能够解析绝大多数的 [ECMAScript 规范的语法](https://github.com/acornjs/acorn/tree/master/acorn)，但还是不支持 TypeScript ，因此需要引入其他的解析器完成 TS 的解析。\n' +
          '\n' +
          '社区提供了`@typescript-eslint/parser`这个解决方案，专门为了 TypeScript 的解析而诞生，将 `TS` 代码转换为 `Espree` 能够识别的格式(即 [**Estree 格式**](https://github.com/estree/estree))，然后在 Eslint 下通过`Espree`进行格式检查， 以此兼容了 TypeScript 语法。\n' +
          '\n' +
          '#### 2. parserOptions  - 解析器选项\n' +
          '\n' +
          '这个配置可以对上述的解析器进行能力定制，默认情况下 ESLint 支持 ES5 语法，你可以配置这个选项，具体内容如下:\n' +
          '\n' +
          '- ecmaVersion: 这个配置和 `Acron` 的 [ecmaVersion](https://github.com/acornjs/acorn/tree/master/acorn) 是兼容的，可以配置 `ES + 数字`(如 ES6)或者`ES + 年份`(如 ES2015)，也可以直接配置为`latest`，启用最新的 ES 语法。\n' +
          '- sourceType: 默认为`script`，如果使用 ES Module 则应设置为`module`\n' +
          '- ecmaFeatures: 为一个对象，表示想使用的额外语言特性，如开启 `jsx`。\n' +
          '\n' +
          '#### 3. rules - 具体代码规则\n' +
          '`rules` 配置即代表在 ESLint 中手动调整哪些代码规则，比如`禁止在 if 语句中使用赋值语句`这条规则可以像如下的方式配置:\n' +
          '```ts\n' +
          '// .eslintrc.js\n' +
          'module.exports = {\n' +
          '  // 其它配置省略\n' +
          '  rules: {\n' +
          '    // key 为规则名，value 配置内容\n' +
          '    "no-cond-assign": ["error", "always"]\n' +
          '  }\n' +
          '}\n' +
          '```\n' +
          '在 rules 对象中，`key` 一般为`规则名`，`value` 为具体的配置内容，在上述的例子中我们设置为一个数组，数组第一项为规则的 `ID`，第二项为`规则的配置`。\n' +
          '\n' +
          '这里重点说一说规则的 ID，它的语法对所有规则都适用，你可以设置以下的值:\n' +
          '- `off` 或 `0`: 表示关闭规则。\n' +
          '- `warn` 或 `1`: 表示开启规则，不过违背规则后只抛出 warning，而不会导致程序退出。\n' +
          '- `error` 或 `2`: 表示开启规则，不过违背规则后抛出 error，程序会退出。\n' +
          '\n' +
          '具体的规则配置可能会不一样，有的是一个字符串，有的可以配置一个对象，你可以参考 [ESLint 官方文档](https://cn.eslint.org/docs/rules/)。\n' +
          '\n' +
          '当然，你也能直接将 `rules` 对象的 `value` 配置成 ID，如: `"no-cond-assign": "error"`。\n' +
          '\n' +
          '#### 4. plugins\n' +
          '上面提到过 ESLint 的 parser 基于`Acorn`实现，不能直接解析 TypeScript，需要我们指定 parser 选项为`@typescript-eslint/parser`才能兼容 TS 的解析。同理，ESLint 本身也没有内置 TypeScript 的代码规则，这个时候 ESLint 的插件系统就派上用场了。我们需要通过添加 ESLint 插件来增加一些特定的规则，比如添加`@typescript-eslint/eslint-plugin` 来拓展一些关于 TS 代码的规则，如下代码所示:\n' +
          '```js\n' +
          '// .eslintrc.js\n' +
          'module.exports = {\n' +
          '  // 添加 TS 规则，可省略`eslint-plugin`\n' +
          "  plugins: ['@typescript-eslint']\n" +
          '}\n' +
          '```\n' +
          '\n' +
          '值得注意的是，添加插件后只是拓展了 ESLint 本身的规则集，但 ESLint 默认并**没有开启**这些规则的校验！如果要开启或者调整这些规则，你需要在 rules 中进行配置，如:\n' +
          '```js\n' +
          '// .eslintrc.js\n' +
          'module.exports = {\n' +
          '  // 开启一些 TS 规则\n' +
          '  rules: {\n' +
          "    '@typescript-eslint/ban-ts-comment': 'error',\n" +
          "    '@typescript-eslint/no-explicit-any': 'warn',\n" +
          '  }\n' +
          '}\n' +
          '```\n' +
          '\n' +
          '\n' +
          '#### 5. extends - 继承配置\n' +
          '\n' +
          'extends 相当于`继承`另外一份 ESLint 配置，可以配置为一个字符串，也可以配置成一个字符串数组。主要分如下 3 种情况:\n' +
          '\n' +
          '1. 从 ESLint 本身继承；\n' +
          '2. 从类似 `eslint-config-xxx` 的 npm 包继承；\n' +
          '3. 从 ESLint 插件继承。\n' +
          '```ts\n' +
          '// .eslintrc.js\n' +
          'module.exports = {\n' +
          '   "extends": [\n' +
          '     // 第1种情况 \n' +
          '     "eslint:recommended",\n' +
          '     // 第2种情况，一般配置的时候可以省略 `eslint-config`\n' +
          '     "standard"\n' +
          '     // 第3种情况，可以省略包名中的 `eslint-plugin`\n' +
          '     // 格式一般为: `plugin:${pluginName}/${configName}`\n' +
          '     "plugin:react/recommended"\n' +
          '     "plugin:@typescript-eslint/recommended",\n' +
          '   ]\n' +
          '}\n' +
          '```\n' +
          '有了 extends 的配置，对于之前所说的 ESLint 插件中的繁多配置，我们就**不需要手动一一开启**了，通过 extends 字段即可自动开启插件中的推荐规则:\n' +
          '```js\n' +
          'extends: ["plugin:@typescript-eslint/recommended"]\n' +
          '```\n' +
          '\n' +
          '#### 6. env 和 globals\n' +
          '这两个配置分别表示`运行环境`和`全局变量`，在指定的运行环境中会预设一些全局变量，比如:\n' +
          '```js\n' +
          '// .eslint.js\n' +
          'module.export = {\n' +
          '  "env": {\n' +
          '    "browser": "true",\n' +
          '    "node": "true"\n' +
          '  }\n' +
          '}\n' +
          '```\n' +
          '指定上述的 `env` 配置后便会启用浏览器和 Node.js 环境，这两个环境中的一些全局变量(如 `window`、`global` 等)会同时启用。\n' +
          '\n' +
          '有些全局变量是业务代码引入的第三方库所声明，这里就需要在`globals`配置中声明全局变量了。每个全局变量的配置值有 3 种情况:\n' +
          '1. `"writable"`或者 `true`，表示变量可重写；\n' +
          '2. `"readonly"`或者`false`，表示变量不可重写；\n' +
          '3. `"off"`，表示禁用该全局变量。\n' +
          '\n' +
          '那`jquery`举例，我们可以在配置文件中声明如下:\n' +
          '```js\n' +
          '// .eslintrc.js\n' +
          'module.exports = {\n' +
          '  "globals": {\n' +
          '    // 不可重写\n' +
          '    "$": false, \n' +
          '    "jQuery": false \n' +
          '  }\n' +
          '}\n' +
          '```\n' +
          '相信有了上述核心配置部分的讲解，你再回头看看初始化生成的 ESLint 配置文件，你也能很好地理解各个配置项的含义了。\n' +
          '\n' +
          '### 与 Prettier 强强联合\n' +
          '虽然 ESLint 本身具备自动格式化代码的功能(`eslint --fix`)，但术业有专攻，ESLint 的主要优势在于`代码的风格检查并给出提示`，而在代码格式化这一块 Prettier 做的更加专业，因此我们经常将 ESLint 结合 Prettier 一起使用。\n' +
          '\n' +
          '首先我们来安装一下 Prettier:\n' +
          '```ts\n' +
          'pnpm i prettier -D\n' +
          '```\n' +
          '在项目根目录新建`.prettierrc.js`配置文件，填写如下的配置内容:\n' +
          '```js\n' +
          '// .prettierrc.js\n' +
          'module.exports = {\n' +
          '  printWidth: 80, //一行的字符数，如果超过会进行换行，默认为80\n' +
          '  tabWidth: 2, // 一个 tab 代表几个空格数，默认为 2 个\n' +
          '  useTabs: false, //是否使用 tab 进行缩进，默认为false，表示用空格进行缩减\n' +
          '  singleQuote: true, // 字符串是否使用单引号，默认为 false，使用双引号\n' +
          '  semi: true, // 行尾是否使用分号，默认为true\n' +
          '  trailingComma: "none", // 是否使用尾逗号\n' +
          '  bracketSpacing: true // 对象大括号直接是否有空格，默认为 true，效果：{ a: 1 }\n' +
          '};\n' +
          '```\n' +
          '\n' +
          '接下来我们将`Prettier`集成到现有的`ESLint`工具中，首先安装两个工具包:\n' +
          '```js\n' +
          'pnpm i eslint-config-prettier eslint-plugin-prettier -D\n' +
          '```\n' +
          '其中`eslint-config-prettier`用来覆盖 ESLint 本身的规则配置，而`eslint-plugin-prettier`则是用于让 Prettier 来接管`eslint --fix`即修复代码的能力。\n' +
          '\n' +
          '在 `.eslintrc.js` 配置文件中接入 prettier 的相关工具链，最终的配置代码如下所示，你可以直接粘贴过去:\n' +
          '```js diff\n' +
          '// .eslintrc.js\n' +
          'module.exports = {\n' +
          '  env: {\n' +
          '    browser: true,\n' +
          '    es2021: true\n' +
          '  },\n' +
          '  extends: [\n' +
          '    "eslint:recommended",\n' +
          '    "plugin:react/recommended",\n' +
          '    "plugin:@typescript-eslint/recommended",\n' +
          '    // 1. 接入 prettier 的规则\n' +
          '    "prettier",\n' +
          '    "plugin:prettier/recommended"\n' +
          '  ],\n' +
          '  parser: "@typescript-eslint/parser",\n' +
          '  parserOptions: {\n' +
          '    ecmaFeatures: {\n' +
          '      jsx: true\n' +
          '    },\n' +
          '    ecmaVersion: "latest",\n' +
          '    sourceType: "module"\n' +
          '  },\n' +
          '  // 2. 加入 prettier 的 eslint 插件\n' +
          '  plugins: ["react", "@typescript-eslint", "prettier"],\n' +
          '  rules: {\n' +
          '    // 3. 注意要加上这一句，开启 prettier 自动修复的功能\n' +
          '    "prettier/prettier": "error",\n' +
          '    quotes: ["error", "single"],\n' +
          '    semi: ["error", "always"],\n' +
          '    "react/react-in-jsx-scope": "off"\n' +
          '  }\n' +
          '};\n' +
          '```\n' +
          'OK，现在我们回到项目中来见证一下`ESLint + Prettier`强强联合的威力，在 `package.json` 中定义一个脚本:\n' +
          '```json\n' +
          '{\n' +
          '  "scripts": {\n' +
          '    // 省略已有 script\n' +
          '    "lint:script": "eslint --ext .js,.jsx,.ts,.tsx --fix --quiet ./",\n' +
          '  }\n' +
          '}\n' +
          '```\n' +
          '接下来在命令行终端执行:\n' +
          '```js\n' +
          'pnpm run lint:script\n' +
          '```\n' +
          '这样我们就完成了 `ESLint 的规则检查`以及 `Prettier 的自动修复`。不过每次执行这个命令未免会有些繁琐，我们可以在`VSCode`中安装`ESLint`和`Prettier`这两个插件，并且在设置区中开启`Format On Save`:\n' +
          '\n' +
          '![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a3d00d6cabd4093b7ce7121464d5bb2~tplv-k3u1fbpfcp-watermark.image?)\n' +
          '\n' +
          '接下来在你按`Ctrl + S`保存代码的时候，Prettier 便会自动帮忙修复代码格式。\n' +
          '\n' +
          '### 在 Vite 中接入 ESLint\n' +
          '\n' +
          '除了安装编辑器插件，我们也可以通过 Vite 插件的方式在开发阶段进行 ESLint 扫描，以命令行的方式展示出代码中的规范问题，并能够直接定位到原文件。\n' +
          '\n' +
          '首先我们安装 Vite 中的 ESLint 插件:\n' +
          '```ts\n' +
          'pnpm i vite-plugin-eslint -D\n' +
          '```\n' +
          '然后在 `vite.config.ts` 中接入:\n' +
          '```ts\n' +
          '// vite.config.ts\n' +
          "import viteEslint from 'vite-plugin-eslint';\n" +
          '\n' +
          '// 具体配置\n' +
          '{\n' +
          '  plugins: [\n' +
          '    // 省略其它插件\n' +
          '    viteEslint(),\n' +
          '  ]\n' +
          '}\n' +
          '```\n' +
          '现在你可以试着重新启动项目， ESLint 的错误已经能够及时显示到命令行窗口中了。\n' +
          '\n' +
          '\n' +
          '![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe73069469414debbef973c6a9f0f8ae~tplv-k3u1fbpfcp-watermark.image?)\n' +
          '\n' +
          '> 由于这个插件采用另一个进程来运行 ESLint 的扫描工作，因此不会影响 Vite 项目的启动速度，这个大家不用担心。\n' +
          '\n' +
          '## 样式规范工具: Stylelint\n' +
          '接下来我们进入`Stylelint`的部分，先来看看官方的定义:\n' +
          '\n' +
          '> Stylelint，一个强大的现代化样式 Lint 工具，用来帮助你避免语法错误和统一代码风格。\n' +
          '\n' +
          'Stylelint 主要专注于样式代码的规范检查，内置了 **170 多个 CSS 书写规则**，支持 **CSS 预处理器**(如 Sass、Less)，提供**插件化机制**以供开发者扩展规则，已经被 Google、Github 等**大型团队**投入使用。与 ESLint 类似，在规范检查方面，Stylelint 已经做的足够专业，而在代码格式化方面，我们仍然需要结合 Prettier 一起来使用。\n' +
          '\n' +
          '首先让我们来安装 Stylelint 以及相应的工具套件：\n' +
          '```ts\n' +
          'pnpm i stylelint stylelint-prettier stylelint-config-prettier stylelint-config-recess-order stylelint-config-standard stylelint-config-standard-scss -D\n' +
          '```\n' +
          '然后，我们在 Stylelint 的配置文件`.stylelintrc.js`中一一使用这些工具套件:\n' +
          '```js\n' +
          '// .stylelintrc.js\n' +
          'module.exports = {\n' +
          '  // 注册 stylelint 的 prettier 插件\n' +
          "  plugins: ['stylelint-prettier'],\n" +
          '  // 继承一系列规则集合\n' +
          '  extends: [\n' +
          '    // standard 规则集合\n' +
          "    'stylelint-config-standard',\n" +
          '    // standard 规则集合的 scss 版本\n' +
          "    'stylelint-config-standard-scss',\n" +
          '    // 样式属性顺序规则\n' +
          "    'stylelint-config-recess-order',\n" +
          '    // 接入 Prettier 规则\n' +
          "    'stylelint-config-prettier',\n" +
          "    'stylelint-prettier/recommended'\n" +
          '  ],\n' +
          '  // 配置 rules\n' +
          '  rules: {\n' +
          '    // 开启 Prettier 自动格式化功能\n' +
          "    'prettier/prettier': true\n" +
          '  }\n' +
          '};\n' +
          '```\n' +
          '可以发现 Stylelint 的配置文件和 ESLint 还是非常相似的，常用的`plugins`、`extends`和`rules`属性在 ESLint 同样存在，并且与 ESLint 中这三个属性的功能也基本相同。不过需要强调的是在 Stylelint 中 rules 的配置会和 ESLint 有些区别，对于每个具体的 rule 会有三种配置方式:\n' +
          '\n' +
          '- `null`，表示关闭规则。\n' +
          '- 一个简单值(如 true，字符串，根据不同规则有所不同)，表示开启规则，但并不做过多的定制。\n' +
          '- 一个数组，包含两个元素，即`[简单值，自定义配置]`，第一个元素通常为一个简单值，第二个元素用来进行更精细化的规则配置。\n' +
          '\n' +
          '接下来我们将 Stylelint 集成到项目中，回到 `package.json` 中，增加如下的 `scripts` 配置:\n' +
          '```json\n' +
          '{\n' +
          '  "scripts": {\n' +
          '    // 整合 lint 命令\n' +
          '    "lint": "npm run lint:script && npm run lint:style",\n' +
          '    // stylelint 命令\n' +
          '    "lint:style": "stylelint --fix \\"src/**/*.{css,scss}\\""\n' +
          '  }\n' +
          '}\n' +
          '```\n' +
          '执行`pnpm run lint:style`即可完成样式代码的规范检查和自动格式化。当然，你也可以在 VSCode 中安装`Stylelint`插件，这样能够在开发阶段即时感知到代码格式问题，提前进行修复。\n' +
          '\n' +
          '当然，我们也可以直接在 Vite 中集成 Stylelint。社区中提供了 Stylelint 的 Vite 插件，实现在项目开发阶段提前暴露出样式代码的规范问题。我们来安装一下这个插件:\n' +
          '```bash\n' +
          'pnpm i @amatlash/vite-plugin-styleli'... 3470 more characters,
        is_free: 0,
        read_time: 2201,
        read_count: 7528,
        comment_count: 94,
        ctime: 1643539182,
        mtime: 1643539182,
        is_update: 0,
        draft_read_time: 2201,
        vid: '',
        reading_progress: {
          id: 0,
          booklet_id: '7050063811973218341',
          user_id: '3289337926283534',
          section_id: '7058853948060336163',
          reading_end: 0,
          reading_progress: 100,
          reading_position: 0,
          has_update: 1,
          last_rtime: 1663414496,
          ctime: 1656249660,
          mtime: 1663414496
        }
      }
    }
  },
  level: 'info',
  label: 'juejin',
  timestamp: '2022-09-18 01:43:26.323 PM'
}
{
  message: {
    err_no: 0,
    err_msg: 'success',
    data: {
      section: {
        id: 86674,
        section_id: '7077834799208988675',
        title: '模块标准：为什么 ESM 是前端模块化的未来？',
        user_id: '430664257382462',
        booklet_id: '7050063811973218341',
        status: 1,
        content: '<p>2002 年 AJAX 诞生至今，前端从刀耕火种的年代，经历了一系列的发展，各种标准和工具百花齐放。下图中我们可以看到，自 2009 年 Node.js 诞生，前端先后出现了 <code>CommonJS</code>、<code>AMD</code>、<code>CMD</code>、<code>UMD</code>和<code>ES Module</code> 等模块规范，底层规范的发展催生出了一系列工具链的创新，比如 AMD 规范提出时社区诞生的模块加载工具<code>requireJS</code>，基于 CommonJS 规范的模块打包工具<code>browserify</code>，还有能让用户提前用上 <code>ES Module</code> 语法的 JS 编译器<code>Babel</code>、兼容各种模块规范的重量级打包工具<code>Webpack</code>以及基于浏览器原生 ES Module 支持而实现的 <strong>no-bundle</strong> 构建工具 <code>Vite</code> 等等。</p>\n' +
          '<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c15509b49d84da58b745d6c1b97f8e7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>\n' +
          '<p>总体而言，业界经历了一系列<strong>由规范、标准引领工程化改革</strong>的过程。构建工具作为前端工程化的核心要素，与底层的前端模块化规范和标准息息相关。接下来的时间，我就带你梳理一下前端模块化是如何演进的。这样你能更清楚地了解到各种模块化标准诞生的背景和意义，也能更好地理解 ES Module 为什么能够成为现今最主流的前端模块化标准。</p>\n' +
          '<h3>无模块化标准阶段</h3>\n' +
          '<p>早在模块化标准还没有诞生的时候，前端界已经产生了一些模块化的开发手段，如<code>文件划分</code>、<code>命名空间</code>和 <code>IIFE 私有作用域</code>。下面，我来简单介绍一下它们的实现以及背后存在的问题。</p>\n' +
          '<h4>1. 文件划分</h4>\n' +
          '<p>文件划分方式是最原始的模块化实现，简单来说就是将应用的状态和逻辑分散到不同的文件中，然后通过 HTML 中的 script 来一一引入。下面是一个通过<code>文件划分</code>实现模块化的具体例子:</p>\n' +
          '<pre><code class="hljs language-ts"><span class="hljs-comment">// module-a.js</span>\n' +
          '<span class="hljs-keyword">let</span> data = <span class="hljs-string">"data"</span>;\n' +
          '</code></pre>\n' +
          '<pre><code class="hljs language-ts"><span class="hljs-comment">// module-b.js</span>\n' +
          '<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">method</span>(<span class="hljs-params"></span>) </span>{\n' +
          '  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"execute method"</span>);\n' +
          '}\n' +
          '</code></pre>\n' +
          '<pre><code class="hljs language-html">// index.html\n' +
          '<span class="hljs-meta">&#x3C;!DOCTYPE <span class="hljs-meta-keyword">html</span>></span>\n' +
          '<span class="hljs-tag">&#x3C;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>></span>\n' +
          '  <span class="hljs-tag">&#x3C;<span class="hljs-name">head</span>></span>\n' +
          '    <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /></span>\n' +
          '    <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge"</span> /></span>\n' +
          '    <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span> /></span>\n' +
          '    <span class="hljs-tag">&#x3C;<span class="hljs-name">title</span>></span>Document<span class="hljs-tag">&#x3C;/<span class="hljs-name">title</span>></span>\n' +
          '  <span class="hljs-tag">&#x3C;/<span class="hljs-name">head</span>></span>\n' +
          '  <span class="hljs-tag">&#x3C;<span class="hljs-name">body</span>></span>\n' +
          '    <span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./module-a.js"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>\n' +
          '    <span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./module-b.js"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>\n' +
          '    <span class="hljs-tag">&#x3C;<span class="hljs-name">script</span>></span><span class="javascript">\n' +
          '      <span class="hljs-built_in">console</span>.log(data);\n' +
          '      method();\n' +
          '    </span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>\n' +
          '  <span class="hljs-tag">&#x3C;/<span class="hljs-name">body</span>></span>\n' +
          '<span class="hljs-tag">&#x3C;/<span class="hljs-name">html</span>></span>\n' +
          '</code></pre>\n' +
          '<p>从中可以看到<code>module-a</code>和<code>module-b</code>为两个不同的模块，通过两个 script 标签分别引入到 HTML 中，这么做看似是分散了不同模块的状态和运行逻辑，但实际上也隐藏着一些风险因素:</p>\n' +
          '<ol>\n' +
          '<li>\n' +
          '<p>模块变量相当于在全局声明和定义，会有变量名冲突的问题。比如 <code>module-b</code> 可能也存在<code>data</code>变量，这就会与 <code>module-a</code> 中的变量冲突。</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>由于变量都在全局定义，我们很难知道某个变量到底属于哪些模块，因此也给调试带来了困难。</p>\n' +
          '</li>\n' +
          '<li>\n' +
          '<p>无法清晰地管理模块之间的依赖关系和加载顺序。假如<code>module-a</code>依赖<code>module-b</code>，那么上述 HTML 的 script 执行顺序需要手动调整，不然可能会产生运行时错误。</p>\n' +
          '</li>\n' +
          '</ol>\n' +
          '<h4>2. 命名空间</h4>\n' +
          '<p><code>命名空间</code>是模块化的另一种实现手段，它可以解决上述文件划分方式中<code>全局变量定义</code>所带来的一系列问题。下面是一个简单的例子:</p>\n' +
          '<pre><code class="hljs language-ts"><span class="hljs-comment">// module-a.js</span>\n' +
          '<span class="hljs-built_in">window</span>.moduleA = {\n' +
          '  <span class="hljs-attr">data</span>: <span class="hljs-string">"moduleA"</span>,\n' +
          '  <span class="hljs-attr">method</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n' +
          `    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"execute A's method"</span>);\n` +
          '  },\n' +
          '};\n' +
          '</code></pre>\n' +
          '<pre><code class="hljs language-ts"><span class="hljs-comment">// module-b.js</span>\n' +
          '<span class="hljs-built_in">window</span>.moduleB = {\n' +
          '  <span class="hljs-attr">data</span>: <span class="hljs-string">"moduleB"</span>,\n' +
          '  <span class="hljs-attr">method</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n' +
          `    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"execute B's method"</span>);\n` +
          '  },\n' +
          '};\n' +
          '</code></pre>\n' +
          '<pre><code class="hljs language-html"><span class="hljs-meta">&#x3C;!DOCTYPE <span class="hljs-meta-keyword">html</span>></span>\n' +
          '<span class="hljs-tag">&#x3C;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>></span>\n' +
          '  <span class="hljs-tag">&#x3C;<span class="hljs-name">head</span>></span>\n' +
          '    <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /></span>\n' +
          '    <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge"</span> /></span>\n' +
          '    <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span> /></span>\n' +
          '    <span class="hljs-tag">&#x3C;<span class="hljs-name">title</span>></span>Document<span class="hljs-tag">&#x3C;/<span class="hljs-name">title</span>></span>\n' +
          '  <span class="hljs-tag">&#x3C;/<span class="hljs-name">head</span>></span>\n' +
          '  <span class="hljs-tag">&#x3C;<span class="hljs-name">body</span>></span>\n' +
          '    <span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./module-a.js"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>\n' +
          '    <span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./module-b.js"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>\n' +
          '    <span class="hljs-tag">&#x3C;<span class="hljs-name">script</span>></span><span class="javascript">\n' +
          '      <span class="hljs-comment">// 此时 window 上已经绑定了 moduleA 和 moduleB</span>\n' +
          '      <span class="hljs-built_in">console</span>.log(moduleA.data);\n' +
          '      moduleB.method();\n' +
          '    </span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>\n' +
          '  <span class="hljs-tag">&#x3C;/<span class="hljs-name">body</span>></span>\n' +
          '<span class="hljs-tag">&#x3C;/<span class="hljs-name">html</span>></span>\n' +
          '</code></pre>\n' +
          '<p>这样一来，每个变量都有自己专属的命名空间，我们可以清楚地知道某个变量到底属于哪个<code>模块</code>，同时也避免全局变量命名的问题。</p>\n' +
          '<h4>3. IIFE(立即执行函数)</h4>\n' +
          '<p>不过，相比于<code>命名空间</code>的模块化手段，<code>IIFE</code>实现的模块化安全性要更高，对于模块作用域的区分更加彻底。你可以参考如下<code>IIFE 实现模块化</code>的例子:</p>\n' +
          '<pre><code class="hljs language-ts"><span class="hljs-comment">// module-a.js</span>\n' +
          '(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n' +
          '  <span class="hljs-keyword">let</span> data = <span class="hljs-string">"moduleA"</span>;\n' +
          '\n' +
          '  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">method</span>(<span class="hljs-params"></span>) </span>{\n' +
          '    <span class="hljs-built_in">console</span>.log(data + <span class="hljs-string">"execute"</span>);\n' +
          '  }\n' +
          '\n' +
          '  <span class="hljs-built_in">window</span>.moduleA = {\n' +
          '    <span class="hljs-attr">method</span>: method,\n' +
          '  };\n' +
          '})();\n' +
          '</code></pre>\n' +
          '<pre><code class="hljs language-ts"><span class="hljs-comment">// module-b.js</span>\n' +
          '(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n' +
          '  <span class="hljs-keyword">let</span> data = <span class="hljs-string">"moduleB"</span>;\n' +
          '\n' +
          '  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">method</span>(<span class="hljs-params"></span>) </span>{\n' +
          '    <span class="hljs-built_in">console</span>.log(data + <span class="hljs-string">"execute"</span>);\n' +
          '  }\n' +
          '\n' +
          '  <span class="hljs-built_in">window</span>.moduleB = {\n' +
          '    <span class="hljs-attr">method</span>: method,\n' +
          '  };\n' +
          '})();\n' +
          '</code></pre>\n' +
          '<pre><code class="hljs language-html">// index.html\n' +
          '<span class="hljs-meta">&#x3C;!DOCTYPE <span class="hljs-meta-keyword">html</span>></span>\n' +
          '<span class="hljs-tag">&#x3C;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>></span>\n' +
          '  <span class="hljs-tag">&#x3C;<span class="hljs-name">head</span>></span>\n' +
          '    <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /></span>\n' +
          '    <span class="hljs-tag">&#x3C;<span class'... 13860 more characters,
        draft_content: '',
        draft_title: '模块标准：为什么 ESM 是前端模块化的未来？',
        markdown_content: '',
        markdown_show: '2002 年 AJAX 诞生至今，前端从刀耕火种的年代，经历了一系列的发展，各种标准和工具百花齐放。下图中我们可以看到，自 2009 年 Node.js 诞生，前端先后出现了 `CommonJS`、`AMD`、`CMD`、`UMD`和`ES Module` 等模块规范，底层规范的发展催生出了一系列工具链的创新，比如 AMD 规范提出时社区诞生的模块加载工具`requireJS`，基于 CommonJS 规范的模块打包工具`browserify`，还有能让用户提前用上 `ES Module` 语法的 JS 编译器`Babel`、兼容各种模块规范的重量级打包工具`Webpack`以及基于浏览器原生 ES Module 支持而实现的 **no-bundle** 构建工具 `Vite` 等等。\n' +
          '\n' +
          '\n' +
          '![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c15509b49d84da58b745d6c1b97f8e7~tplv-k3u1fbpfcp-zoom-1.image)\n' +
          '\n' +
          '\n' +
          '总体而言，业界经历了一系列**由规范、标准引领工程化改革**的过程。构建工具作为前端工程化的核心要素，与底层的前端模块化规范和标准息息相关。接下来的时间，我就带你梳理一下前端模块化是如何演进的。这样你能更清楚地了解到各种模块化标准诞生的背景和意义，也能更好地理解 ES Module 为什么能够成为现今最主流的前端模块化标准。\n' +
          '\n' +
          '### 无模块化标准阶段\n' +
          '\n' +
          '早在模块化标准还没有诞生的时候，前端界已经产生了一些模块化的开发手段，如`文件划分`、`命名空间`和 `IIFE 私有作用域`。下面，我来简单介绍一下它们的实现以及背后存在的问题。\n' +
          '\n' +
          '#### 1. 文件划分\n' +
          '\n' +
          '文件划分方式是最原始的模块化实现，简单来说就是将应用的状态和逻辑分散到不同的文件中，然后通过 HTML 中的 script 来一一引入。下面是一个通过`文件划分`实现模块化的具体例子:\n' +
          '\n' +
          '```ts\n' +
          '// module-a.js\n' +
          'let data = "data";\n' +
          '```\n' +
          '\n' +
          '```ts\n' +
          '// module-b.js\n' +
          'function method() {\n' +
          '  console.log("execute method");\n' +
          '}\n' +
          '```\n' +
          '\n' +
          '```html\n' +
          '// index.html\n' +
          '<!DOCTYPE html>\n' +
          '<html lang="en">\n' +
          '  <head>\n' +
          '    <meta charset="UTF-8" />\n' +
          '    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n' +
          '    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n' +
          '    <title>Document</title>\n' +
          '  </head>\n' +
          '  <body>\n' +
          '    <script src="./module-a.js"></script>\n' +
          '    <script src="./module-b.js"></script>\n' +
          '    <script>\n' +
          '      console.log(data);\n' +
          '      method();\n' +
          '    </script>\n' +
          '  </body>\n' +
          '</html>\n' +
          '```\n' +
          '\n' +
          '从中可以看到`module-a`和`module-b`为两个不同的模块，通过两个 script 标签分别引入到 HTML 中，这么做看似是分散了不同模块的状态和运行逻辑，但实际上也隐藏着一些风险因素:\n' +
          '\n' +
          '1. 模块变量相当于在全局声明和定义，会有变量名冲突的问题。比如 `module-b` 可能也存在`data`变量，这就会与 `module-a` 中的变量冲突。\n' +
          '\n' +
          '2. 由于变量都在全局定义，我们很难知道某个变量到底属于哪些模块，因此也给调试带来了困难。\n' +
          '\n' +
          '3. 无法清晰地管理模块之间的依赖关系和加载顺序。假如`module-a`依赖`module-b`，那么上述 HTML 的 script 执行顺序需要手动调整，不然可能会产生运行时错误。\n' +
          '\n' +
          '#### 2. 命名空间\n' +
          '\n' +
          '`命名空间`是模块化的另一种实现手段，它可以解决上述文件划分方式中`全局变量定义`所带来的一系列问题。下面是一个简单的例子:\n' +
          '\n' +
          '```ts\n' +
          '// module-a.js\n' +
          'window.moduleA = {\n' +
          '  data: "moduleA",\n' +
          '  method: function () {\n' +
          `    console.log("execute A's method");\n` +
          '  },\n' +
          '};\n' +
          '```\n' +
          '\n' +
          '```ts\n' +
          '// module-b.js\n' +
          'window.moduleB = {\n' +
          '  data: "moduleB",\n' +
          '  method: function () {\n' +
          `    console.log("execute B's method");\n` +
          '  },\n' +
          '};\n' +
          '```\n' +
          '\n' +
          '```html\n' +
          '<!DOCTYPE html>\n' +
          '<html lang="en">\n' +
          '  <head>\n' +
          '    <meta charset="UTF-8" />\n' +
          '    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n' +
          '    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n' +
          '    <title>Document</title>\n' +
          '  </head>\n' +
          '  <body>\n' +
          '    <script src="./module-a.js"></script>\n' +
          '    <script src="./module-b.js"></script>\n' +
          '    <script>\n' +
          '      // 此时 window 上已经绑定了 moduleA 和 moduleB\n' +
          '      console.log(moduleA.data);\n' +
          '      moduleB.method();\n' +
          '    </script>\n' +
          '  </body>\n' +
          '</html>\n' +
          '```\n' +
          '\n' +
          '这样一来，每个变量都有自己专属的命名空间，我们可以清楚地知道某个变量到底属于哪个`模块`，同时也避免全局变量命名的问题。\n' +
          '\n' +
          '#### 3. IIFE(立即执行函数)\n' +
          '\n' +
          '不过，相比于`命名空间`的模块化手段，`IIFE`实现的模块化安全性要更高，对于模块作用域的区分更加彻底。你可以参考如下`IIFE 实现模块化`的例子:\n' +
          '\n' +
          '```ts\n' +
          '// module-a.js\n' +
          '(function () {\n' +
          '  let data = "moduleA";\n' +
          '\n' +
          '  function method() {\n' +
          '    console.log(data + "execute");\n' +
          '  }\n' +
          '\n' +
          '  window.moduleA = {\n' +
          '    method: method,\n' +
          '  };\n' +
          '})();\n' +
          '```\n' +
          '\n' +
          '```ts\n' +
          '// module-b.js\n' +
          '(function () {\n' +
          '  let data = "moduleB";\n' +
          '\n' +
          '  function method() {\n' +
          '    console.log(data + "execute");\n' +
          '  }\n' +
          '\n' +
          '  window.moduleB = {\n' +
          '    method: method,\n' +
          '  };\n' +
          '})();\n' +
          '```\n' +
          '\n' +
          '```html\n' +
          '// index.html\n' +
          '<!DOCTYPE html>\n' +
          '<html lang="en">\n' +
          '  <head>\n' +
          '    <meta charset="UTF-8" />\n' +
          '    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n' +
          '    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n' +
          '    <title>Document</title>\n' +
          '  </head>\n' +
          '  <body>\n' +
          '    <script src="./module-a.js"></script>\n' +
          '    <script src="./module-b.js"></script>\n' +
          '    <script>\n' +
          '      // 此时 window 上已经绑定了 moduleA 和 moduleB\n' +
          '      console.log(moduleA.data);\n' +
          '      moduleB.method();\n' +
          '    </script>\n' +
          '  </body>\n' +
          '</html>\n' +
          '```\n' +
          '\n' +
          '我们知道，每个`IIFE` 即`立即执行函数`都会创建一个私有的作用域，在私有作用域中的变量外界是无法访问的，只有模块内部的方法才能访问。拿上述的`module-a`来说:\n' +
          '\n' +
          '```ts\n' +
          '// module-a.js\n' +
          '(function () {\n' +
          '  let data = "moduleA";\n' +
          '\n' +
          '  function method() {\n' +
          '    console.log(data + "execute");\n' +
          '  }\n' +
          '\n' +
          '  window.moduleA = {\n' +
          '    method: method,\n' +
          '  };\n' +
          '})();\n' +
          '```\n' +
          '\n' +
          '对于其中的 `data`变量，我们只能在模块内部的 `method` 函数中通过闭包访问，而在其它模块中无法直接访问。这就是模块`私有成员`功能，避免模块私有成员被其他模块非法篡改，相比于`命名空间`的实现方式更加安全。\n' +
          '\n' +
          '但实际上，无论是`命名空间`还是`IIFE`，都是为了解决全局变量所带来的命名冲突及作用域不明确的问题，也就是在`文件划分方式`中所总结的`问题 1` 和`问题 2`，而并没有真正解决另外一个问题——**模块加载**。如果模块间存在依赖关系，那么 script 标签的加载顺序就需要受到严格的控制，一旦顺序不对，则很有可能产生运行时 Bug。\n' +
          '\n' +
          '而随着前端工程的日益庞大，各个模块之间相互依赖已经是非常常见的事情，模块加载的需求已经成为了业界刚需，而以上的几种非标准模块化手段不能满足这个需求，因此我们需要指定一个行业标准去统一前端代码的模块化。\n' +
          '\n' +
          '不过前端的模块化规范统一也经历了漫长的发展阶段，即便是到现在也没有实现完全的统一。接下来，我们就来熟悉一下业界主流的三大模块规范: `CommonJS`、`AMD` 和 `ES Module`。\n' +
          '\n' +
          '### CommonJS 规范\n' +
          '\n' +
          'CommonJS 是业界最早正式提出的 JavaScript 模块规范，主要用于服务端，随着 Node.js 越来越普及，这个规范也被业界广泛应用。对于模块规范而言，一般会包含 2 方面内容:\n' +
          '\n' +
          '-   统一的模块化代码规范\n' +
          '\n' +
          '-   实现自动加载模块的加载器(也称`loader`)\n' +
          '\n' +
          '对于 CommonJS 模块规范本身，相信有 Node.js 使用经验的同学都不陌生了，为了方便你理解，我举一个使用 CommonJS 的简单例子:\n' +
          '\n' +
          '```ts\n' +
          '// module-a.js\n' +
          'var data = "hello world";\n' +
          'function getData() {\n' +
          '  return data;\n' +
          '}\n' +
          'module.exports = {\n' +
          '  getData,\n' +
          '};\n' +
          '\n' +
          '// index.js\n' +
          'const { getData } = require("./module-a.js");\n' +
          'console.log(getData());\n' +
          '```\n' +
          '\n' +
          '代码中使用 `require` 来导入一个模块，用`module.exports`来导出一个模块。实际上 Node.js 内部会有相应的 loader 转译模块代码，最后模块代码会被处理成下面这样:\n' +
          '\n' +
          '```ts\n' +
          '(function (exports, require, module, __filename, __dirname) {\n' +
          '  // 执行模块代码\n' +
          '  // 返回 exports 对象\n' +
          '});\n' +
          '```\n' +
          '\n' +
          '对 CommonJS 而言，一方面它定义了一套完整的模块化代码规范，另一方面 Node.js 为之实现了自动加载模块的`loader`，看上去是一个很不错的模块规范，但也存在一些问题:\n' +
          '\n' +
          '1.  模块加载器由 Node.js 提供，依赖了 Node.js 本身的功能实现，比如文件系统，如果 CommonJS 模块直接放到浏览器中是无法执行的。当然, 业界也产生了 [browserify](https://github.com/browserify/browserify) 这种打包工具来支持打包 CommonJS 模块，从而顺利在浏览器中执行，相当于社区实现了一个第三方的 loader。\n' +
          '2.  CommonJS 本身约定以同步的方式进行模块加载，这种加载机制放在服务端是没问题的，一来模块都在本地，不需要进行网络 IO，二来只有服务启动时才会加载模块，而服务通常启动后会一直运行，所以对服务的性能并没有太大的影响。但如果这种加载机制放到浏览器端，会带来明显的性能问题。它会产生大量同步的模块请求，浏览器要等待响应返回后才能继续解析模块。也就是说，**模块请求会造成浏览器 JS 解析过程的阻塞**，导致页面加载速度缓慢。\n' +
          '\n' +
          '总之，CommonJS 是一个不太适合在浏览器中运行的模块规范。因此，业界也设计出了全新的规范来作为浏览器端的模块标准，最知名的要数 `AMD` 了。\n' +
          '\n' +
          '### AMD 规范\n' +
          '\n' +
          '`AMD`全称为`Asynchronous Module Definition`，即异步模块定义规范。模块根据这个规范，在浏览器环境中会被异步加载，而不会像 CommonJS 规范进行同步加载，也就不会产生同步请求导致的浏览器解析过程阻塞的问题了。我们先来看看这个模块规范是如何来使用的:\n' +
          '\n' +
          '```ts\n' +
          '// main.js\n' +
          'define(["./print"], function (printModule) {\n' +
          '  printModule.print("main");\n' +
          '});\n' +
          '\n' +
          '// print.js\n' +
          'define(function () {\n' +
          '  return {\n' +
          '    print: function (msg) {\n' +
          '      console.log("print " + msg);\n' +
          '    },\n' +
          '  };\n' +
          '});\n' +
          '```\n' +
          '\n' +
          '在 AMD 规范当中，我们可以通过 define 去定义或加载一个模块，比如上面的 `main` 模块和`print`模块，如果模块需要导出一些成员需要通过在定义模块的函数中 return 出去(参考 `print` 模块)，如果当前模块依赖了一些其它的模块则可以通过 define 的第一个参数来声明依赖(参考`main`模块)，这样模块的代码执行之前浏览器会先**加载依赖模块**。\n' +
          '\n' +
          '当然，你也可以使用 require 关键字来加载一个模块，如:\n' +
          '\n' +
          '```ts\n' +
          '// module-a.js\n' +
          'require(["./print.js"], function (printModule) {\n' +
          '  printModule.print("module-a");\n' +
          '});\n' +
          '```\n' +
          '\n' +
          '不过 require 与 define 的区别在于前者只能加载模块，而`不能定义一个模块`。\n' +
          '\n' +
          '由于没有得到浏览器的原生支持，AMD 规范需要由第三方的 loader 来实现，最经典的就是 [requireJS](https://github.com/requirejs/requirejs) 库了，它完整实现了 AMD 规范，至今仍然有不少项目在使用。\n' +
          '\n' +
          '不过 AMD 规范使用起来稍显复杂，代码阅读和书写都比较困难。因此，这个规范并不能成为前端模块化的终极解决方案，仅仅是社区中提出的一个妥协性的方案，关于新的模块化规范的探索，业界从仍未停止脚步。\n' +
          '\n' +
          '同期出现的规范当中也有 CMD 规范，这个规范是由淘宝出品的`SeaJS`实现的，解决的问题和 AMD 一样。不过随着社区的不断发展，SeaJS 已经被`requireJS`兼容了。\n' +
          '\n' +
          '> 当然，你可能也听说过 `UMD` (Universal Module Definition)规范，其实它并不算一个新的规范，只是兼容 AMD 和 CommonJS 的一个模块化方案，可以同时运行在浏览器和 Node.js 环境。顺便提一句，后面将要介绍的 ES Module 也具备这种跨平台的能力。\n' +
          '\n' +
          '### ES6 Module\n' +
          '\n' +
          '`ES6 Module` 也被称作 `ES Module`(或 `ESM`)， 是由 ECMAScript 官方提出的模块化规范，作为一个官方提出的规范，`ES Module` 已经得到了现代浏览器的内置支持。在现代浏览器中，如果在 HTML 中加入含有`type="module"`属性的 script 标签，那么浏览器会按照 ES Module 规范来进行依赖加载和模块解析，这也是 Vite 在开发阶段实现 no-bundle 的原因，由于模块加载的任务交给了浏览器，即使不打包也可以顺利运行模块代码，具体的模块加载流程我们会在下一节进行详细的解释。\n' +
          '\n' +
          '大家可能会担心 ES Module 的兼容性问题，其实 ES Module 的浏览器兼容性如今已经相当好了，覆盖了 90% 以上的浏览器份额，在 [CanIUse](https://caniuse.com/) 上的详情数据如下图所示:\n' +
          '\n' +
          '![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a538b478a6e743fcb5dd5849cf07fcc8~tplv-k3u1fbpfcp-zoom-1.image)\n' +
          '\n' +
          '不仅如此，一直以 CommonJS 作为模块标准的 Node.js 也紧跟 ES Module 的发展步伐，从 `12.20` 版本开始[正式支持](https://nodejs.org/api/esm.html#modules-ecmascript-modules)原生 ES Module。也就是说，如今 ES Module 能够同时在浏览器与 Node.js 环境中执行，拥有天然的跨平台能力。\n' +
          '\n' +
          '下面是一个使用 ES Module 的简单例子:\n' +
          '\n' +
          '```ts\n' +
          '// main.js\n' +
          'import { methodA } from "./module-a.js";\n' +
          'methodA();\n' +
          '\n' +
          '//module-a.js\n' +
          'const methodA = () => {\n' +
          '  console.log("a");\n' +
          '};\n' +
          '\n' +
          'export { methodA };\n' +
          '```\n' +
          '\n' +
          '```html\n' +
          '<!DOCTYPE html>\n' +
          '<html lang="en">\n' +
          '  <head>\n' +
          '    <meta charset="UTF-8" />\n' +
          '    <link rel="icon" type="image/svg+xml" href="/src/favicon.svg" />\n' +
          '    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n' +
          '    <title>Vite App</title>\n' +
          '  </head>\n' +
          '  <body>\n' +
          '    <div id="root"></div>\n' +
          '    <script type="module" src="./main.js"></script>\n' +
          '  </body>\n' +
          '</html>\n' +
          '```\n' +
          '\n' +
          '如果在 Node.js 环境中，你可以在`package.json`中声明`type: "module"`属性:\n' +
          '\n' +
          '```ts\n' +
          '// package.json\n' +
          '{\n' +
          '  "type": "module"\n' +
          '}\n' +
          '```\n' +
          '\n' +
          '然后 Node.js 便会默认以 ES Module 规范去解析模块:\n' +
          '\n' +
          '```ts\n' +
          'node main.js\n' +
          '// 打印 a\n' +
          '```\n' +
          '\n' +
          '顺便说一句，在 Node.js 中，即使是在 CommonJS 模块里面，也可以通过 `import` 方法顺利加载 ES 模块，如下所示:\n' +
          '\n' +
          '```ts\n' +
          'async function func() {\n' +
          '  // 加载一个 ES 模块\n' +
          '  // 文件名后缀需要是 mjs\n' +
          '  const { a } = await import("./module-a.mjs");\n' +
          '  console.log(a);\n' +
          '}\n' +
          '\n' +
          'func();\n' +
          '\n' +
          'module.exports = {\n' +
          '  func,\n' +
          '};\n' +
          '```\n' +
          '\n' +
          'ES Module 作为 ECMAScript 官方提出的规范，经过五年多的发展，不仅得到了众多浏览器的原生支持，也在 Node.js 中得到了原生支持，是一个能够跨平台的模块规范。同时，它也是社区各种生态库的发展趋势，尤其是被如今大火的构建工具 Vite 所深度应用。可以说，ES Module 前景一片光明，成为前端大一统的模块标准指日可待。\n' +
          '\n' +
          '当然，这一讲我们只简单介绍了 ESM。至于高级特性，我们将在「高级应用篇」专门介绍。你可以先利用我这里给到的官方资料提前预习： [MDN 官方解释](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules)、[ECMAScript 内部提案细节](https://262.ecma-international.org/6.0/#sec-modules)。\n' +
          '\n' +
          '## 小结\n' +
          '这一节，我们要重点掌握**前端模块化的诞生意义**、**主流的模块化规范**和 **ESM 规范的优势**。\n' +
          '\n' +
          '由于前端构建工具的改革与底层模块化规范的发展息息相关，从一开始我就带你从头梳理了前端模块化的演进史，从无模块化标准的时代开始谈起，跟你介绍了`文件划分`的模块化方案，并分析了这个方案潜在的几个问题。随后又介绍了`命名空间`和`IIFE`两种方案，但这两种方式并没有解决模块自动加载的问题。由此展开对前端模块化规范的介绍，我主要给你分析了三个主流的模块化标准: `CommonJS`、`AMD` 以及 `ES Module`，针对每个规范从`模块化代码标准`、`模块自动加载方案`这两个维度给你进行了详细的拆解，最后得出 ES Module 即将成为主流前端模块化方案的结论。\n' +
          '\n' +
          '本小节的内容就到这里了，希望能对你有所启发，也欢迎你把自己的学习心得打到评论区，我们下一节再见~',
        is_free: 0,
        read_time: 1988,
        read_count: 8291,
        comment_count: 37,
        ctime: 1648023179,
        mtime: 1648023179,
        is_update: 0,
        draft_read_time: 1988,
        vid: '',
        reading_progress: {
          id: 0,
          booklet_id: '7050063811973218341',
          user_id: '3289337926283534',
          section_id: '7077834799208988675',
          reading_end: 0,
          reading_progress: 100,
          reading_position: 17,
          has_update: 1,
          last_rtime: 1663479116,
          ctime: 1656247440,
          mtime: 1663479276
        }
      }
    }
  },
  level: 'info',
  label: 'juejin',
  timestamp: '2022-09-18 01:43:26.348 PM'
}
{
  message: {
    err_no: 0,
    err_msg: 'success',
    data: {
      section: {
        id: 85932,
        section_id: '7053634868994899975',
        title: '快速上手: 如何用 Vite 从零搭建前端项目？',
        user_id: '430664257382462',
        booklet_id: '7050063811973218341',
        status: 1,
        content: '<p>通过前面的学习，我们已经知道了前端构建工具的意义，也明确了 Vite 相比于传统构建工具 Webpack 的优势。相信对于为什么要学习和使用 Vite 这个问题，你已经有了自己的答案。</p>\n' +
          '<p>回到实际的应用场景当中，我们应该如何使用 Vite 来搭建前端工程项目呢？这一节，我将和你一起近距离接触 Vite，学完本节你不仅能学会前端开发环境的搭建，更重要的是，你能上手使用 Vite 来初始化一个脚手架项目，并理解这个项目究竟是如何运行起来的。</p>\n' +
          '<h2>环境搭建</h2>\n' +
          '<p>首先需要的是代码编辑器和浏览器，我推荐安装<code>VSCode</code>和<code>Chrome</code>浏览器。</p>\n' +
          '<p>其次是安装 Node.js，如果你的系统中还没有安装 <a href="http://nodejs.cn/download/current/" target="_blank" rel="nofollow noopener noreferrer"><code>Node.js</code></a> ，可以进入 Nodejs 官网下载相应的安装包进行手动安装；如果已经安装了 <code>Node.js</code>，你可以使用这个命令检查一下 Node.js 版本:</p>\n' +
          '<pre><code class="hljs language-js">node -v\n' +
          '</code></pre>\n' +
          '<p>推荐 <code>12.0.0</code> 及以上版本，如果低于这个版本，推荐使用 <a href="https://github.com/nvm-sh/nvm" target="_blank" rel="nofollow noopener noreferrer"><code>nvm</code></a> 工具切换 Nodejs 版本。</p>\n' +
          '<p>安装完 Nodejs 之后，包管理器<code>npm</code>也会被自动安装，你可以执行下面的命令来验证:</p>\n' +
          '<pre><code class="hljs language-bash">npm -v\n' +
          '</code></pre>\n' +
          '<p>当然，在现代的前端项目中，我非常不推荐使用 npm 作为项目的包管理器，甚至也不再推荐<code>yarn</code>(<code>npm</code> 的替代方案)，因为两者都存在比较严重的性能和安全问题，而这些问题在 pnpm 中得到了很好的解决，更多细节可以参考我的这篇博客: <a href="https://juejin.cn/post/6932046455733485575" target="_blank" rel="nofollow noopener noreferrer">关于现代包管理器的深度思考——为什么现在我更推荐 pnpm 而不是 npm/yarn?\n' +
          '</a>。</p>\n' +
          '<p>因此，包管理器方面我推荐使用 pnpm，安装方式非常简单，输入如下命令即可:</p>\n' +
          '<pre><code class="hljs language-js">npm i -g pnpm\n' +
          '</code></pre>\n' +
          '<p>由于默认的镜像源在国外，包下载速度和稳定性都不太好，因此我建议你换成国内的镜像源，这样<code>pnpm install</code>命令的体验会好很多，命令如下:</p>\n' +
          '<pre><code class="hljs language-bash">pnpm config <span class="hljs-built_in">set</span> registry https://registry.npmmirror.com/\n' +
          '</code></pre>\n' +
          '<h2>项目初始化</h2>\n' +
          '<p>在搭建了基本的开发环境之后，我们进入到<code>项目初始化</code>阶段。你可以在终端命令行中输入如下的命令:</p>\n' +
          '<pre><code class="hljs language-js">pnpm create vite\n' +
          '</code></pre>\n' +
          '<p>在执行完这个命令后，pnpm 首先会自动下载 <code>create-vite</code> 这个第三方包，然后执行这个包中的项目初始化逻辑。因此，你很快就可以看到这样的交互界面:</p>\n' +
          '<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7ca5186aa324841ba4f038642e355f3~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>\n' +
          '<p>后续的交互流程梳理如下:</p>\n' +
          '<ul>\n' +
          '<li>\n' +
          '<ol>\n' +
          '<li>输入项目名称；</li>\n' +
          '</ol>\n' +
          '</li>\n' +
          '<li>\n' +
          '<ol start="2">\n' +
          '<li>选择前端框架；</li>\n' +
          '</ol>\n' +
          '</li>\n' +
          '<li>\n' +
          '<ol start="3">\n' +
          '<li>选择开发语言。</li>\n' +
          '</ol>\n' +
          '</li>\n' +
          '</ul>\n' +
          '<p>首先是输入项目名称，这里你可以输入<code>vite-project</code>，然后按下回车，进入<code>选择前端框架</code>的部分:</p>\n' +
          '<pre><code class="hljs language-ts">✔ Project name: vite-project\n' +
          '? Select a framework: › - Use arrow-keys. Return to submit.\n' +
          '    vanilla <span class="hljs-comment">// 无前端框架</span>\n' +
          '    vue     <span class="hljs-comment">// 基于 Vue </span>\n' +
          ' >  react   <span class="hljs-comment">// 基于 React</span>\n' +
          '    preact  <span class="hljs-comment">// 基于 Preact（一款精简版的类 React 框架）</span>\n' +
          '    lit     <span class="hljs-comment">// 基于 lit（一款 Web Components 框架） </span>\n' +
          '    svelte  <span class="hljs-comment">// 基于 Svelte</span>\n' +
          '</code></pre>\n' +
          '<p>Vite 内置了以上不同前端框架的脚手架模板，这里我们以其中的<code>react</code>框架为例来讲解，选择<code>react</code>并按回车，紧接着选择<code>react-ts</code>完成命令交互。</p>\n' +
          '<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7ce24dcb52946168fa4e28773dabc7a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>\n' +
          '<p>好，现在脚手架的模板已经生成完毕。你可以执行如下命令在本地启动项目:</p>\n' +
          '<pre><code class="hljs language-js"><span class="hljs-comment">// 进入项目目录</span>\n' +
          'cd vite-project\n' +
          '<span class="hljs-comment">// 安装依赖</span>\n' +
          'pnpm install\n' +
          '<span class="hljs-comment">// 启动项目</span>\n' +
          'pnpm run dev\n' +
          '</code></pre>\n' +
          '<p>执行<code>pnpm run dev</code>之后你可以看到如下界面，表示项目已经成功启动啦。</p>\n' +
          '<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8ca697e5ca449f7af195245957856ff~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>\n' +
          '<p>紧接着，我们立马去浏览器中打开<code>http://localhost:3000</code>页面，你可以看到：</p>\n' +
          '<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f4da134800544caacbc5834d347ff32~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>\n' +
          '<p>至此，我们成功搭建起了一个 React 前端项目。怎么样？利用 Vite 来初始化一个前端项目是不是非常简单？经过初步尝试，Vite 给人的第一感觉就是简洁、轻量、快速。我曾经拿 react 官方基于 Webpack 的脚手架<code>create-react-app</code>，也就是大家常说的<code>cra</code>来测试过，从项目初始化到依赖安装所花的时间与 Vite 对比如下:</p>\n' +
          '<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2adc237d5bbd409ca9c32fb7d36aa272~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>\n' +
          '<p>Vite 已经比 cra 快了接近 6 倍，并且一开始就甩了 cra 一大截，显而易见地提升了初始化速度和开发体验。</p>\n' +
          '<h2>项目入口加载</h2>\n' +
          '<p>言归正传，我们继续学习 Vite 初始化后的项目。项目的目录结构如下:</p>\n' +
          '<pre><code class="hljs language-bash">.\n' +
          '├── index.html\n' +
          '├── package.json\n' +
          '├── pnpm-lock.yaml\n' +
          '├── src\n' +
          '│   ├── App.css\n' +
          '│   ├── App.tsx\n' +
          '│   ├── favicon.svg\n' +
          '│   ├── index.css\n' +
          '│   ├── logo.svg\n' +
          '│   ├── main.tsx\n' +
          '│   └── vite-env.d.ts\n' +
          '├── tsconfig.json\n' +
          '└── vite.config.ts\n' +
          '</code></pre>\n' +
          '<p>值得注意的是，在项目根目录中有一个<code>index.html</code>文件，这个文件十分关键，因为 Vite 默认会把项目根目录下的<code>index.html</code>作为入口文件。也就是说，当你访问<code>http://localhost:3000</code>的时候，Vite 的 Dev Server 会自动返回这个 HTML 文件的内容。我们来看看这个 HTML 究竟写了什么:</p>\n' +
          '<pre><code class="hljs language-js">&#x3C;!DOCTYPE html>\n' +
          '<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>></span>\n' +
          '  <span class="hljs-tag">&#x3C;<span class="hljs-name">head</span>></span>\n' +
          '    <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /></span>\n' +
          '    <span class="hljs-tag">&#x3C;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"icon"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"image/svg+xml"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/src/favicon.svg"</span> /></span>\n' +
          '    <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span> /></span>\n' +
          '    <span class="hljs-tag">&#x3C;<span class="hljs-name">title</span>></span>Vite App<span class="hljs-tag">&#x3C;/<span class="hljs-name">title</span>></span>\n' +
          '  <span class="hljs-tag">&#x3C;/<span class="hljs-name">head</span>></span>\n' +
          '  <span class="hljs-tag">&#x3C;<span class="hljs-name">body</span>></span>\n' +
          '    <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>\n' +
          '    <span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/src/main.tsx"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>\n' +
          '  <span class="hljs-tag">&#x3C;/<span class="hljs-name">body</span>></span>\n' +
          '<span class="hljs-tag">&#x3C;/<span class="hljs-name">html</span>></span></span>\n' +
          '</code></pre>\n' +
          '<p>可以看到这个 HTML 文件的内容非常简洁，在 <code>body</code> 标签中除了 id 为 root 的根节点之外，还包含了一个声明了<code>type="module"</code>的 <code>script</code> 标签:</p>\n' +
          '<pre><code class="hljs language-html"><span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/src/main.tsx"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>\n' +
          '</code></pre>\n' +
          '<p>由于现代浏览器原生支持了 ES 模块规范，因此原生的 ES 语法也可以直接放到浏览器中执行，只需要在 script 标签中声明 <code>type="module"</code> 即可。比如上面的 script 标签就声明了 type="module"，同时 src 指向了<code>/src/main.tsx</code>文件，此时相当于请求了<code>http://localhost:3000/src/main.tsx</code>这个资源，Vite 的 Dev Server 此时会接受到这个请求，然后读取对应的文件内容，进行一定的中间处理，最后将处理的结果返回给浏览器。</p>\n' +
          '<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee292d2f8917407ca8f47e94f8d8aeed~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>\n' +
          '<p>我们可以来看看 <code>main.tsx</code> 的内容:</p>\n' +
          `<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>\n` +
          `<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>\n` +
          `<span class="hljs-keyword">import</span> <span class="hljs-string">'./index.css'</span>\n` +
          `<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span>\n` +
          '\n' +
          'ReactDOM.render(\n' +
          '  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">React.StrictMode</span>></span>\n' +
          '    <span class="hljs-tag">&#x3C;<span class="hljs-name">App</span> /></span>\n' +
          '  <span class="hljs-tag">&#x3C;/<span class="hljs-name">React.StrictMode</span>></span></span>,\n' +
          `  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>)\n` +
          ')\n' +
          '</code></pre>\n' +
          '<p>到这里可能你会诧异: 浏览器并不识别 tsx 语法，也无法直接 import css 文件，上面这段代码究竟是如何被浏览器正常执行的呢？</p>\n' +
          '<p>这就归功了 Vite Dev Server 所做的“中间处理”了，也就是说，在读取到 <code>main.tsx</code>文件的内容之后，Vite 会对文件的内容进行编译，大家可以从 Chrome 的网络调试面板看到编译后的结果:</p>\n' +
          '<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e77d3505dfb24a42b53c6c986fb83e71~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>\n' +
          '<p>当然，大家不用纠结每句代码的含义，因为这涉及 Vite 内部的编译流程，我们会在后面的章节深入分析。这里你只需要知道，Vite 会将项目的源代码编译成浏览器可以识别的代码，与此同时，一个 import 语句即代表了一个 HTTP 请求，如下面两个 import 语句:</p>\n' +
          '<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">"/src/index.css"</span>;\n' +
          '<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">"/src/App.tsx"</span>;\n' +
          '</code></pre>\n' +
          '<p>需要注意的是，在 Vite 项目中，一个<code>import 语句即代表一个 HTTP 请求</code>。上述两个语句则分别代表了两个不同的请求，Vite Dev Server 会读取本地文件，返回浏览器可以解析的代码。当浏览器解析到新的 import 语句，又会发出新的请求，以此类推，直到所有的资源都加载完成。</p>\n' +
          '<p>现在，你应该知道了 Vite 所倡导的<code>no-bundle</code>理念的真正含义: <strong>利用浏览器原生 ES 模块的支持，实现开发阶段的 Dev Server，进行模块的按需加载</strong>，而不是<strong>先整体打包再进行加载</strong>。相比 Webpack 这种必须打包再加载的传统构建模式，Vite 在开发阶段省略了繁琐且耗时的打包过程，这也是它为什么快的一个重要原因。</p>\n' +
          '<h2>初识配置文件</h2>\n' +
          '<p>在使用 Vite 的过程，我们需要对 Vite 做一些配置，以满足日常开发的需要。你可以通过两种方式来对 Vite 进行配置，一是通过命令行参数，如<code>vite --port=8888</code>，二是通过配置文件，一般情况下，大多数的配置都通过配置文件的方式来声明。</p>\n' +
          '<p>Vite 当中支持多种配置文件类型，包括<code>.js</code>、<code>.ts</code>、<code>.mjs</code>三种后缀的文件，实际项目中一般使用<code>vite.c'... 4759 more characters,
        draft_content: '',
        draft_title: '快速上手: 如何用 Vite 从零搭建前端项目？',
        markdown_content: '',
        markdown_show: '通过前面的学习，我们已经知道了前端构建工具的意义，也明确了 Vite 相比于传统构建工具 Webpack 的优势。相信对于为什么要学习和使用 Vite 这个问题，你已经有了自己的答案。\n' +
          '\n' +
          '回到实际的应用场景当中，我们应该如何使用 Vite 来搭建前端工程项目呢？这一节，我将和你一起近距离接触 Vite，学完本节你不仅能学会前端开发环境的搭建，更重要的是，你能上手使用 Vite 来初始化一个脚手架项目，并理解这个项目究竟是如何运行起来的。\n' +
          '\n' +
          '## 环境搭建\n' +
          '首先需要的是代码编辑器和浏览器，我推荐安装`VSCode`和`Chrome`浏览器。\n' +
          '\n' +
          '其次是安装 Node.js，如果你的系统中还没有安装 [`Node.js`](http://nodejs.cn/download/current/) ，可以进入 Nodejs 官网下载相应的安装包进行手动安装；如果已经安装了 `Node.js`，你可以使用这个命令检查一下 Node.js 版本:\n' +
          '\n' +
          '```js\n' +
          'node -v\n' +
          '```\n' +
          '\n' +
          '推荐 `12.0.0` 及以上版本，如果低于这个版本，推荐使用 [`nvm`](https://github.com/nvm-sh/nvm) 工具切换 Nodejs 版本。\n' +
          '\n' +
          '安装完 Nodejs 之后，包管理器`npm`也会被自动安装，你可以执行下面的命令来验证:\n' +
          '```bash\n' +
          'npm -v\n' +
          '```\n' +
          '\n' +
          '当然，在现代的前端项目中，我非常不推荐使用 npm 作为项目的包管理器，甚至也不再推荐`yarn`(`npm` 的替代方案)，因为两者都存在比较严重的性能和安全问题，而这些问题在 pnpm 中得到了很好的解决，更多细节可以参考我的这篇博客: [关于现代包管理器的深度思考——为什么现在我更推荐 pnpm 而不是 npm/yarn?\n' +
          '](https://juejin.cn/post/6932046455733485575)。\n' +
          '\n' +
          '因此，包管理器方面我推荐使用 pnpm，安装方式非常简单，输入如下命令即可:\n' +
          '```js\n' +
          'npm i -g pnpm\n' +
          '```\n' +
          '\n' +
          '由于默认的镜像源在国外，包下载速度和稳定性都不太好，因此我建议你换成国内的镜像源，这样`pnpm install`命令的体验会好很多，命令如下:\n' +
          '```bash\n' +
          'pnpm config set registry https://registry.npmmirror.com/\n' +
          '```\n' +
          '\n' +
          '## 项目初始化\n' +
          '在搭建了基本的开发环境之后，我们进入到`项目初始化`阶段。你可以在终端命令行中输入如下的命令:\n' +
          '```js\n' +
          'pnpm create vite\n' +
          '```\n' +
          '\n' +
          '在执行完这个命令后，pnpm 首先会自动下载 `create-vite` 这个第三方包，然后执行这个包中的项目初始化逻辑。因此，你很快就可以看到这样的交互界面:\n' +
          '\n' +
          '![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7ca5186aa324841ba4f038642e355f3~tplv-k3u1fbpfcp-zoom-1.image)\n' +
          '\n' +
          '后续的交互流程梳理如下:\n' +
          '\n' +
          '- 1. 输入项目名称；\n' +
          '- 2. 选择前端框架；\n' +
          '- 3. 选择开发语言。\n' +
          '\n' +
          '首先是输入项目名称，这里你可以输入`vite-project`，然后按下回车，进入`选择前端框架`的部分:\n' +
          '```ts\n' +
          '✔ Project name: vite-project\n' +
          '? Select a framework: › - Use arrow-keys. Return to submit.\n' +
          '    vanilla // 无前端框架\n' +
          '    vue     // 基于 Vue \n' +
          ' >  react   // 基于 React\n' +
          '    preact  // 基于 Preact（一款精简版的类 React 框架）\n' +
          '    lit     // 基于 lit（一款 Web Components 框架） \n' +
          '    svelte  // 基于 Svelte\n' +
          '```\n' +
          'Vite 内置了以上不同前端框架的脚手架模板，这里我们以其中的`react`框架为例来讲解，选择`react`并按回车，紧接着选择`react-ts`完成命令交互。\n' +
          '\n' +
          '![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7ce24dcb52946168fa4e28773dabc7a~tplv-k3u1fbpfcp-zoom-1.image)\n' +
          '\n' +
          '好，现在脚手架的模板已经生成完毕。你可以执行如下命令在本地启动项目:\n' +
          '```js\n' +
          '// 进入项目目录\n' +
          'cd vite-project\n' +
          '// 安装依赖\n' +
          'pnpm install\n' +
          '// 启动项目\n' +
          'pnpm run dev\n' +
          '```\n' +
          '执行`pnpm run dev`之后你可以看到如下界面，表示项目已经成功启动啦。\n' +
          '\n' +
          '![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8ca697e5ca449f7af195245957856ff~tplv-k3u1fbpfcp-zoom-1.image)\n' +
          '\n' +
          '紧接着，我们立马去浏览器中打开`http://localhost:3000`页面，你可以看到：\n' +
          '\n' +
          '\n' +
          '![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f4da134800544caacbc5834d347ff32~tplv-k3u1fbpfcp-zoom-1.image)\n' +
          '\n' +
          '至此，我们成功搭建起了一个 React 前端项目。怎么样？利用 Vite 来初始化一个前端项目是不是非常简单？经过初步尝试，Vite 给人的第一感觉就是简洁、轻量、快速。我曾经拿 react 官方基于 Webpack 的脚手架`create-react-app`，也就是大家常说的`cra`来测试过，从项目初始化到依赖安装所花的时间与 Vite 对比如下:\n' +
          '\n' +
          '\n' +
          '![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2adc237d5bbd409ca9c32fb7d36aa272~tplv-k3u1fbpfcp-zoom-1.image)\n' +
          '\n' +
          'Vite 已经比 cra 快了接近 6 倍，并且一开始就甩了 cra 一大截，显而易见地提升了初始化速度和开发体验。\n' +
          '\n' +
          '## 项目入口加载\n' +
          '\n' +
          '言归正传，我们继续学习 Vite 初始化后的项目。项目的目录结构如下:\n' +
          '```bash\n' +
          '.\n' +
          '├── index.html\n' +
          '├── package.json\n' +
          '├── pnpm-lock.yaml\n' +
          '├── src\n' +
          '│   ├── App.css\n' +
          '│   ├── App.tsx\n' +
          '│   ├── favicon.svg\n' +
          '│   ├── index.css\n' +
          '│   ├── logo.svg\n' +
          '│   ├── main.tsx\n' +
          '│   └── vite-env.d.ts\n' +
          '├── tsconfig.json\n' +
          '└── vite.config.ts\n' +
          '```\n' +
          '值得注意的是，在项目根目录中有一个`index.html`文件，这个文件十分关键，因为 Vite 默认会把项目根目录下的`index.html`作为入口文件。也就是说，当你访问`http://localhost:3000`的时候，Vite 的 Dev Server 会自动返回这个 HTML 文件的内容。我们来看看这个 HTML 究竟写了什么:\n' +
          '```js\n' +
          '<!DOCTYPE html>\n' +
          '<html lang="en">\n' +
          '  <head>\n' +
          '    <meta charset="UTF-8" />\n' +
          '    <link rel="icon" type="image/svg+xml" href="/src/favicon.svg" />\n' +
          '    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n' +
          '    <title>Vite App</title>\n' +
          '  </head>\n' +
          '  <body>\n' +
          '    <div id="root"></div>\n' +
          '    <script type="module" src="/src/main.tsx"></script>\n' +
          '  </body>\n' +
          '</html>\n' +
          '```\n' +
          '可以看到这个 HTML 文件的内容非常简洁，在 `body` 标签中除了 id 为 root 的根节点之外，还包含了一个声明了`type="module"`的 `script` 标签:\n' +
          '```html\n' +
          '<script type="module" src="/src/main.tsx"></script>\n' +
          '```\n' +
          '由于现代浏览器原生支持了 ES 模块规范，因此原生的 ES 语法也可以直接放到浏览器中执行，只需要在 script 标签中声明 `type="module"` 即可。比如上面的 script 标签就声明了 type="module"，同时 src 指向了`/src/main.tsx`文件，此时相当于请求了`http://localhost:3000/src/main.tsx`这个资源，Vite 的 Dev Server 此时会接受到这个请求，然后读取对应的文件内容，进行一定的中间处理，最后将处理的结果返回给浏览器。\n' +
          '\n' +
          '\n' +
          '![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee292d2f8917407ca8f47e94f8d8aeed~tplv-k3u1fbpfcp-zoom-1.image)\n' +
          '\n' +
          '\n' +
          '我们可以来看看 `main.tsx` 的内容:\n' +
          '```ts\n' +
          "import React from 'react'\n" +
          "import ReactDOM from 'react-dom'\n" +
          "import './index.css'\n" +
          "import App from './App'\n" +
          '\n' +
          'ReactDOM.render(\n' +
          '  <React.StrictMode>\n' +
          '    <App />\n' +
          '  </React.StrictMode>,\n' +
          "  document.getElementById('root')\n" +
          ')\n' +
          '```\n' +
          '\n' +
          '到这里可能你会诧异: 浏览器并不识别 tsx 语法，也无法直接 import css 文件，上面这段代码究竟是如何被浏览器正常执行的呢？\n' +
          '\n' +
          '这就归功了 Vite Dev Server 所做的“中间处理”了，也就是说，在读取到 `main.tsx`文件的内容之后，Vite 会对文件的内容进行编译，大家可以从 Chrome 的网络调试面板看到编译后的结果:\n' +
          '\n' +
          '\n' +
          '![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e77d3505dfb24a42b53c6c986fb83e71~tplv-k3u1fbpfcp-zoom-1.image)\n' +
          '\n' +
          '\n' +
          '当然，大家不用纠结每句代码的含义，因为这涉及 Vite 内部的编译流程，我们会在后面的章节深入分析。这里你只需要知道，Vite 会将项目的源代码编译成浏览器可以识别的代码，与此同时，一个 import 语句即代表了一个 HTTP 请求，如下面两个 import 语句:\n' +
          '```js\n' +
          'import "/src/index.css";\n' +
          'import App from "/src/App.tsx";\n' +
          '```\n' +
          '需要注意的是，在 Vite 项目中，一个`import 语句即代表一个 HTTP 请求`。上述两个语句则分别代表了两个不同的请求，Vite Dev Server 会读取本地文件，返回浏览器可以解析的代码。当浏览器解析到新的 import 语句，又会发出新的请求，以此类推，直到所有的资源都加载完成。\n' +
          '\n' +
          '现在，你应该知道了 Vite 所倡导的`no-bundle`理念的真正含义: **利用浏览器原生 ES 模块的支持，实现开发阶段的 Dev Server，进行模块的按需加载**，而不是**先整体打包再进行加载**。相比 Webpack 这种必须打包再加载的传统构建模式，Vite 在开发阶段省略了繁琐且耗时的打包过程，这也是它为什么快的一个重要原因。\n' +
          '\n' +
          '## 初识配置文件\n' +
          '在使用 Vite 的过程，我们需要对 Vite 做一些配置，以满足日常开发的需要。你可以通过两种方式来对 Vite 进行配置，一是通过命令行参数，如`vite --port=8888`，二是通过配置文件，一般情况下，大多数的配置都通过配置文件的方式来声明。\n' +
          '\n' +
          'Vite 当中支持多种配置文件类型，包括`.js`、`.ts`、`.mjs`三种后缀的文件，实际项目中一般使用`vite.config.ts`作为配置文件，以脚手架项目中的配置为例，具体的配置代码如下:\n' +
          '\n' +
          '```ts\n' +
          '// vite.config.ts\n' +
          "import { defineConfig } from 'vite'\n" +
          "import react from '@vitejs/plugin-react'\n" +
          '\n' +
          'export default defineConfig({\n' +
          '  plugins: [react()]\n' +
          '})\n' +
          '```\n' +
          '\n' +
          '可以看到配置文件中默认在 `plugins` 数组中配置了官方的 react 插件，来提供 React 项目编译和热更新的功能。\n' +
          '\n' +
          '接下来，我们可以基于这个文件完成更加丰富的配置。之前我就遇到过这样一个需求: 页面的入口文件`index.html`并不在项目根目录下，而需要放到 `src` 目录下，如何在访问`localhost:3000`的时候让 Vite 自动返回 src 目录下的`index.html`呢？我们可以通过`root`参数配置项目根目录的位置:\n' +
          '\n' +
          '```ts\n' +
          '// vite.config.ts\n' +
          "import { defineConfig } from 'vite'\n" +
          '// 引入 path 包注意两点:\n' +
          '// 1. 为避免类型报错，你需要通过 `pnpm i @types/node -D` 安装类型\n' +
          '// 2. tsconfig.node.json 中设置 `allowSyntheticDefaultImports: true`，以允许下面的 default 导入方式\n' +
          "import path from 'path'\n" +
          "import react from '@vitejs/plugin-react'\n" +
          '\n' +
          'export default defineConfig({\n' +
          '  // 手动指定项目根目录位置\n' +
          "  root: path.join(__dirname, 'src')\n" +
          '  plugins: [react()]\n' +
          '})\n' +
          '```\n' +
          '当手动指定`root`参数之后，Vite 会自动从这个路径下寻找`index.html`文件，也就是说当我直接访问 `localhost:3000`的时候，Vite 从`src`目录下读取入口文件，这样就成功实现了刚才的需求。\n' +
          '\n' +
          '当然，这只是让你体验了一个简单的配置案例，在 Vite 中还有非常多的配置，由于篇幅所限，本文就不再逐个进行演示了，对于一些经常使用或者比较难理解的配置，后面的文章中会给大家一一介绍。\n' +
          '\n' +
          '## 生产环境构建\n' +
          '有人说`Vite`因为其不打包的特性而不能上生产环境，其实这种观点是相当有误的。在开发阶段 Vite 通过 Dev Server 实现了不打包的特性，而在生产环境中，Vite 依然会基于 Rollup 进行打包，并采取一系列的打包优化手段。从脚手架项目的`package.json`中就可见一斑：\n' +
          '```js\n' +
          '"scripts": {\n' +
          '  // 开发阶段启动 Vite Dev Server\n' +
          '  "dev": "vite",\n' +
          '  // 生产环境打包\n' +
          '  "build": "tsc && vite build",\n' +
          '  // 生产环境打包完预览产物\n' +
          '  "preview": "vite preview"\n' +
          '},\n' +
          '```\n' +
          '相信你已经注意到其中的`build`命令了，没错，这个命令就是 Vite 专门用来进行生产环境打包的。但可能你会有点疑惑，为什么在`vite build`命令执行之前要先执行`tsc`呢？\n' +
          '\n' +
          '`tsc` 作为 TypeScript 的官方编译命令，可以用来编译 TypeScript 代码并进行类型检查，而这里的作用主要是用来做类型检查，我们可以从项目的`tsconfig.json`中注意到这样一个配置:\n' +
          '```ts\n' +
          '{\n' +
          '  "compilerOptions": {\n' +
          '    // 省略其他配置\n' +
          '    // 1. noEmit 表示只做类型检查，而不会输出产物文件\n' +
          '    // 2. 这行配置与 tsc --noEmit 命令等效\n' +
          '    "noEmit": true,\n' +
          '  },\n' +
          '}\n' +
          '```\n' +
          '虽然 Vite 提供了开箱即用的 TypeScript 以及 JSX 的编译能力，但实际上底层并没有实现 TypeScript 的类型校验系统，因此需要借助 `tsc` 来完成类型校验(在 Vue 项目中使用 `vue-tsc` 这个工具来完成)，在打包前提早暴露出类型相关的问题，保证代码的健壮性。\n' +
          '\n' +
          '接下来你可以试着执行一下这个打包命令:\n' +
          '\n' +
          '![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a2eadd5fcd143c7aa55f12979d8b3f0~tplv-k3u1fbpfcp-zoom-1.image)\n' +
          '\n' +
          '此时 Vite 已经生成了最终的打包产物，我们可以通过 `pnpm run preview` 命令预览一下打包产物的执行效果。\n' +
          '\n' +
          '\n' +
          '![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e845b0e8c2f24b3a901bdc53754e80c9~tplv-k3u1fbpfcp-zoom-1.image)\n' +
          '\n' +
          '在浏览器中打开`http://localhost:5000`地址，你将看到和开发阶段一样的页面内容，证明我们成功完成第一个 Vite 项目的生产环境构建。\n' +
          '\n' +
          '## 小结\n' +
          '恭喜你完成了本节的学习！在这一小节中，我们正式地开始近距离接触 Vite，使用它来初始化第一个 Vite 项目。\n' +
          '\n' +
          '在最开始，我们一起搭建了基本的前端开发环境，安装常用的编辑器、浏览器、Node.js 环境及包管理器 pnpm，接着我和你使用 Vite 的初始化命令创建一个 React 项目并成功启动，让你真切地体验到 Vite 的快速和轻量。\n' +
          '\n' +
          '项目启动之后我也与你分析了项目背后的启动流程，强调了`一个 import 语句代表一个 HTTP 请求`，而正是 Vite 的 Dev Server 来接收这些请求、进行文件转译以及返回浏览器可以运行的代码，从而让项目正常运行。\n' +
          '\n' +
          '不仅如此，我还带你一起初步接触了 Vite 的配置文件，并尝试进行生产环境的打包，为下一节的学习作下了铺垫。在下一小节中，我们将通过 Vite 搭建起一个相对完整的工程化项目框架，你也将会面临更多的开发场景和挑战，逐渐对 Vite 的使用轻车熟路，让我们下一节再见！',
        is_free: 0,
        read_time: 1229,
        read_count: 8436,
        comment_count: 61,
        ctime: 1642328835,
        mtime: 1642328835,
        is_update: 0,
        draft_read_time: 1229,
        vid: '',
        reading_progress: {
          id: 0,
          booklet_id: '7050063811973218341',
          user_id: '3289337926283534',
          section_id: '7053634868994899975',
          reading_end: 0,
          reading_progress: 100,
          reading_position: 0,
          has_update: 1,
          last_rtime: 1663414495,
          ctime: 1656247440,
          mtime: 1663414494
        }
      }
    }
  },
  level: 'info',
  label: 'juejin',
  timestamp: '2022-09-18 01:43:26.359 PM'
}
{
  message: {
    err_no: 0,
    err_msg: 'success',
    data: {
      section: {
        id: 86098,
        section_id: '7057872229589057576',
        title: '样式方案：在 Vite 中接入现代化的 CSS 工程化方案',
        user_id: '430664257382462',
        booklet_id: '7050063811973218341',
        status: 1,
        content: '<p>上一小节，我们使用 Vite 初始化了一个 Web 项目，迈出了使用 Vite 的第一步。但在实际工作中，仅用 Vite 官方的脚手架项目是不够的，往往还需要考虑诸多的工程化因素，借助 Vite 本身的配置以及业界的各种生态，才能搭建一个名副其实的脚手架工程。</p>\n' +
          '<p>那在接下来的几个小节内容中，我们将以<code>实战</code>的方式逐个击破项目工程化的要素。你可以跟着我一起进行编码，从0搭建一个完整的 Vite 项目架构。不仅如此，在实战的过程中，你也会对 Vite 本身的功能有全面了解，能够熟练地将它应用到实际项目。</p>\n' +
          '<p>样式方案是前端工程化离不开的一个话题，也是本节要具体探讨的内容。在最原始的开发阶段大家都是手写原生的 CSS，但原生 CSS 存在着诸多问题。本小节，我们通过引入现代的各种 CSS 样式方案，一起动手实践，让你学会如何在 Vite 中落地这些样式方案。</p>\n' +
          '<h2>样式方案的意义</h2>\n' +
          '<p>对初学者来说，谈到开发前端的样式，首先想到的便是直接写原生 CSS。但时间一长，难免会发现原生 CSS 开发的各种问题。那么，如果我们不用任何 CSS 工程方案，又会出现哪些问题呢？</p>\n' +
          '<ol>\n' +
          '<li><strong>开发体验</strong>欠佳。比如原生 CSS 不支持选择器的嵌套:</li>\n' +
          '</ol>\n' +
          '<pre><code class="hljs language-css">// 选择器只能平铺，不能嵌套\n' +
          '<span class="hljs-selector-class">.container</span> <span class="hljs-selector-class">.header</span> <span class="hljs-selector-class">.nav</span> <span class="hljs-selector-class">.title</span> <span class="hljs-selector-class">.text</span> {\n' +
          '  <span class="hljs-attribute">color</span>: blue;\n' +
          '}\n' +
          '\n' +
          '<span class="hljs-selector-class">.container</span> <span class="hljs-selector-class">.header</span> <span class="hljs-selector-class">.nav</span> <span class="hljs-selector-class">.box</span> {\n' +
          '  <span class="hljs-attribute">color</span>: blue;\n' +
          '  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid grey;\n' +
          '}\n' +
          '</code></pre>\n' +
          '<ol start="2">\n' +
          '<li><strong>样式污染</strong>问题。如果出现同样的类名，很容易造成不同的样式互相覆盖和污染。</li>\n' +
          '</ol>\n' +
          '<pre><code class="hljs language-ts"><span class="hljs-comment">// a.css</span>\n' +
          '.container {\n' +
          '  <span class="hljs-attr">color</span>: red;\n' +
          '}\n' +
          '\n' +
          '<span class="hljs-comment">// b.css</span>\n' +
          '<span class="hljs-comment">// 很有可能覆盖 a.css 的样式！</span>\n' +
          '.container {\n' +
          '  <span class="hljs-attr">color</span>: blue;\n' +
          '}\n' +
          '</code></pre>\n' +
          '<ol start="3">\n' +
          '<li><strong>浏览器兼容</strong>问题。为了兼容不同的浏览器，我们需要对一些属性(如<code>transition</code>)加上不同的浏览器前缀，比如 <code>-webkit-</code>、<code>-moz-</code>、<code>-ms-</code>、<code>-o-</code>，意味着开发者要针对同一个样式属性写很多的冗余代码。</li>\n' +
          '<li>打包后的<strong>代码体积</strong>问题。如果不用任何的 CSS 工程化方案，所有的 CSS 代码都将打包到产物中，即使有部分样式并没有在代码中使用，导致产物体积过大。</li>\n' +
          '</ol>\n' +
          '<p>针对如上原生 CSS 的痛点，社区中诞生了不少解决方案，常见的有 5 类。</p>\n' +
          '<ol>\n' +
          '<li><code>CSS 预处理器</code>：主流的包括<code>Sass/Scss</code>、<code>Less</code>和<code>Stylus</code>。这些方案各自定义了一套语法，让 CSS 也能使用嵌套规则，甚至能像编程语言一样定义变量、写条件判断和循环语句，大大增强了样式语言的灵活性，解决原生 CSS 的<strong>开发体验问题</strong>。</li>\n' +
          '<li><code>CSS Modules</code>：能将 CSS 类名处理成哈希值，这样就可以避免同名的情况下<strong>样式污染</strong>的问题。</li>\n' +
          '<li>CSS 后处理器<code>PostCSS</code>，用来解析和处理 CSS 代码，可以实现的功能非常丰富，比如将 <code>px</code> 转换为 <code>rem</code>、根据目标浏览器情况自动加上类似于<code>--moz--</code>、<code>-o-</code>的属性前缀等等。</li>\n' +
          '<li><code>CSS in JS</code> 方案，主流的包括<code>emotion</code>、<code>styled-components</code>等等，顾名思义，这类方案可以实现直接在 JS 中写样式代码，基本包含<code>CSS 预处理器</code>和 <code>CSS Modules</code> 的各项优点，非常灵活，解决了开发体验和全局样式污染的问题。</li>\n' +
          '<li>CSS 原子化框架，如<code>Tailwind CSS</code>、<code>Windi CSS</code>，通过类名来指定样式，大大简化了样式写法，提高了样式开发的效率，主要解决了原生 CSS <strong>开发体验</strong>的问题。</li>\n' +
          '</ol>\n' +
          '<p>不过，各种方案没有孰优孰劣，各自解决的方案有重叠的部分，但也有一定的差异，大家可以根据自己项目的痛点来引入。接下来，我们进入实战阶段，在 Vite 中应用上述常见的 CSS 方案。</p>\n' +
          '<h3>CSS 预处理器</h3>\n' +
          '<p>Vite 本身对 CSS 各种预处理器语言(<code>Sass/Scss</code>、<code>Less</code>和<code>Stylus</code>)做了内置支持。也就是说，即使你不经过任何的配置也可以直接使用各种 CSS 预处理器。我们以 <code>Sass/Scss</code> 为例，来具体感受一下 Vite 的<code>零配置</code>给我们带来的便利。</p>\n' +
          '<p>由于 Vite 底层会调用 CSS 预处理器的官方库进行编译，而 Vite 为了实现按需加载，并没有内置这些工具库，而是让用户根据需要安装。因此，我们首先安装 Sass 的官方库，安装命令如下:</p>\n' +
          '<pre><code class="hljs language-bash">pnpm i sass -D\n' +
          '</code></pre>\n' +
          '<p>然后，在上一节初始化后的项目中新建 <code>src/components/Header</code> 目录，并且分别新建<code>index.tsx</code> 和 <code>index.scss</code>文件，代码如下:</p>\n' +
          '<pre><code class="hljs language-ts"><span class="hljs-comment">// index.tsx</span>\n' +
          `<span class="hljs-keyword">import</span> <span class="hljs-string">'./index.scss'</span>;\n` +
          '<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Header</span>(<span class="hljs-params"></span>) </span>{\n' +
          '  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"header"</span>></span>This is Header<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span></span>\n' +
          '};\n' +
          '\n' +
          '<span class="hljs-comment">// index.scss</span>\n' +
          '.header {\n' +
          '  <span class="hljs-attr">color</span>: red;\n' +
          '}\n' +
          '</code></pre>\n' +
          '<p>这样就完成了一个最简单的 demo 组件。接着我们在 <code>App.tsx</code> 应用这个组件:</p>\n' +
          '<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { Header } <span class="hljs-keyword">from</span> <span class="hljs-string">"./components/Header"</span>;\n' +
          '\n' +
          '<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{\n' +
          '  <span class="hljs-keyword">return</span> (\n' +
          '    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>\n' +
          '      <span class="hljs-tag">&#x3C;<span class="hljs-name">Header</span> /></span>\n' +
          '    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>\n' +
          '  );\n' +
          '}\n' +
          '\n' +
          '<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;\n' +
          '</code></pre>\n' +
          '<p>现在你可以执行<code>pnpm run dev</code>，然后到浏览器上查看效果:</p>\n' +
          '<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f2b53ea3fd74ef6bd7029749a282b91~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>\n' +
          '<p>内容比较简单，如果页面出现红色的文字部分，就说明 <code>scss</code> 文件中的样式已经成功生效。好，现在我们封装一个全局的主题色，新建<code>src/variable.scss</code>文件，内容如下:</p>\n' +
          '<pre><code class="hljs language-scss"><span class="hljs-comment">// variable.scss</span>\n' +
          '<span class="hljs-variable">$theme-color</span>: red;\n' +
          '</code></pre>\n' +
          '<p>然后，我们在原来 Header 组件的样式中应用这个变量:</p>\n' +
          '<pre><code class="hljs language-scss"><span class="hljs-keyword">@import</span> <span class="hljs-string">"../../variable"</span>;\n' +
          '\n' +
          '<span class="hljs-selector-class">.header</span> {\n' +
          '  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$theme-color</span>;\n' +
          '}\n' +
          '</code></pre>\n' +
          '<p>回到浏览器访问页面，可以看到样式依然生效。你可能会注意到，每次要使用<code>$theme-color</code>属性的时候我们都需要手动引入<code>variable.scss</code>文件，那有没有自动引入的方案呢？这就需要在 Vite 中进行一些自定义配置了，在配置文件中增加如下的内容:</p>\n' +
          '<pre><code class="hljs language-ts"><span class="hljs-comment">// vite.config.ts</span>\n' +
          `<span class="hljs-keyword">import</span> { normalizePath } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>;\n` +
          '<span class="hljs-comment">// 如果类型报错，需要安装 @types/node: pnpm i @types/node -D</span>\n' +
          `<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>;\n` +
          '\n' +
          '<span class="hljs-comment">// 全局 scss 文件的路径</span>\n' +
          '<span class="hljs-comment">// 用 normalizePath 解决 window 下的路径问题</span>\n' +
          `<span class="hljs-keyword">const</span> variablePath = normalizePath(path.resolve(<span class="hljs-string">'./src/variable.scss'</span>));\n` +
          '\n' +
          '\n' +
          '<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineConfig({\n' +
          '  <span class="hljs-comment">// css 相关的配置</span>\n' +
          '  <span class="hljs-attr">css</span>: {\n' +
          '    <span class="hljs-attr">preprocessorOptions</span>: {\n' +
          '      <span class="hljs-attr">scss</span>: {\n' +
          '        <span class="hljs-comment">// additionalData 的内容会在每个 scss 文件的开头自动注入</span>\n' +
          '        <span class="hljs-attr">additionalData</span>: <span class="hljs-string">`@import "<span class="hljs-subst">${variablePath}</span>";`</span>\n' +
          '      }\n' +
          '    }\n' +
          '  }\n' +
          '})\n' +
          '</code></pre>\n' +
          '<p>现在你可以直接在文件中使用全局文件的变量，相当于之前手动引入的方式显然方便了许多:</p>\n' +
          '<pre><code class="hljs language-scss"><span class="hljs-selector-class">.header</span> {\n' +
          '  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$theme-color</span>;\n' +
          '}\n' +
          '</code></pre>\n' +
          '<p>同样的，你可以对 <code>less</code>和<code>stylus</code>进行一些能力的配置，如果有需要你可以去下面的官方文档中查阅更多的配置项:</p>\n' +
          '<ul>\n' +
          '<li><a href="https://sass-lang.com/documentation/js-api/modules#render" target="_blank" rel="nofollow noopener noreferrer">Sass</a></li>\n' +
          '<li><a href="https://lesscss.org/usage/#less-options" target="_blank" rel="nofollow noopener noreferrer">Less</a></li>\n' +
          '<li><a href="https://stylus-lang.com/docs/js.html" target="_blank" rel="nofollow noopener noreferrer">Stylus</a></li>\n' +
          '</ul>\n' +
          '<h3>CSS Modules</h3>\n' +
          '<p>CSS Modules 在 Vite 也是一个开箱即用的能力，Vite 会对后缀带有<code>.module</code>的样式文件自动应用 CSS Modules。接下来我们通过一个简单的例子来使用这个功能。</p>\n' +
          '<p>首先，将 Header 组件中的<code>index.scss</code>更名为<code>index.module.scss</code>，然后稍微改动一下<code>index.tsx</code>的内容，如下:</p>\n' +
          '<pre><code class="hljs language-ts"><span class="hljs-comment">// index.tsx</span>\n' +
          `<span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">'./index.module.scss'</span>;\n` +
          '<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Header</span>(<span class="hljs-params"></span>) </span>{\n' +
          '  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.header}</span>></span>This is Header<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span></span>\n' +
          '};\n' +
          '</code></pre>\n' +
          '<p>现在打开浏览器，可以看见 p 标签的类名已经被处理成了哈希值的形式:</p>\n' +
          '<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b81adefe16484da98bebf6174db36300~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>\n' +
          '<p>说明现在 CSS Modules 已经正式生效了！同样的，你也可以在配置文件中的<code>css.modules</code>选项来配置 CSS Modules 的功能，比如下面这个例子:</p>\n' +
          '<pre><code class="hljs language-ts"><span class="hljs-comment">// vite.config.ts</span>\n' +
          '<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n' +
          '  <span class="hljs-attr">css</span>: {\n' +
          '    <span class="hljs-attr">modules</span>: {\n' +
          '      <span class="hljs-comment">// 一般我们可以通过 generateScopedName 属性来对生成的类名进行自定义</span>\n' +
          '      <span class="hljs-comment">// 其中，name 表示当前文件名，local 表示类名</span>\n' +
          '      <span class="hljs-attr">generateScopedName</span>: <span class="hljs-string">"[name]__[local]___[hash:base64:5]"</span>\n' +
          '    },\n' +
          '    <span class="hljs-attr">preprocessorOptions</span>: {\n' +
          '      <span class="hljs-comment">// 省略预处理器配置</sp'... 15019 more characters,
        draft_content: '',
        draft_title: '样式方案：在 Vite 中接入现代化的 CSS 工程化方案',
        markdown_content: '',
        markdown_show: '上一小节，我们使用 Vite 初始化了一个 Web 项目，迈出了使用 Vite 的第一步。但在实际工作中，仅用 Vite 官方的脚手架项目是不够的，往往还需要考虑诸多的工程化因素，借助 Vite 本身的配置以及业界的各种生态，才能搭建一个名副其实的脚手架工程。\n' +
          '\n' +
          '那在接下来的几个小节内容中，我们将以`实战`的方式逐个击破项目工程化的要素。你可以跟着我一起进行编码，从0搭建一个完整的 Vite 项目架构。不仅如此，在实战的过程中，你也会对 Vite 本身的功能有全面了解，能够熟练地将它应用到实际项目。\n' +
          '\n' +
          '样式方案是前端工程化离不开的一个话题，也是本节要具体探讨的内容。在最原始的开发阶段大家都是手写原生的 CSS，但原生 CSS 存在着诸多问题。本小节，我们通过引入现代的各种 CSS 样式方案，一起动手实践，让你学会如何在 Vite 中落地这些样式方案。\n' +
          '\n' +
          '\n' +
          '## 样式方案的意义\n' +
          '\n' +
          '对初学者来说，谈到开发前端的样式，首先想到的便是直接写原生 CSS。但时间一长，难免会发现原生 CSS 开发的各种问题。那么，如果我们不用任何 CSS 工程方案，又会出现哪些问题呢？\n' +
          '\n' +
          '1. **开发体验**欠佳。比如原生 CSS 不支持选择器的嵌套:\n' +
          '```css\n' +
          '// 选择器只能平铺，不能嵌套\n' +
          '.container .header .nav .title .text {\n' +
          '  color: blue;\n' +
          '}\n' +
          '\n' +
          '.container .header .nav .box {\n' +
          '  color: blue;\n' +
          '  border: 1px solid grey;\n' +
          '}\n' +
          '```\n' +
          '2. **样式污染**问题。如果出现同样的类名，很容易造成不同的样式互相覆盖和污染。\n' +
          '```ts\n' +
          '// a.css\n' +
          '.container {\n' +
          '  color: red;\n' +
          '}\n' +
          '\n' +
          '// b.css\n' +
          '// 很有可能覆盖 a.css 的样式！\n' +
          '.container {\n' +
          '  color: blue;\n' +
          '}\n' +
          '```\n' +
          '3. **浏览器兼容**问题。为了兼容不同的浏览器，我们需要对一些属性(如`transition`)加上不同的浏览器前缀，比如 `-webkit-`、`-moz-`、`-ms-`、`-o-`，意味着开发者要针对同一个样式属性写很多的冗余代码。\n' +
          '4. 打包后的**代码体积**问题。如果不用任何的 CSS 工程化方案，所有的 CSS 代码都将打包到产物中，即使有部分样式并没有在代码中使用，导致产物体积过大。\n' +
          '\n' +
          '针对如上原生 CSS 的痛点，社区中诞生了不少解决方案，常见的有 5 类。\n' +
          '1. `CSS 预处理器`：主流的包括`Sass/Scss`、`Less`和`Stylus`。这些方案各自定义了一套语法，让 CSS 也能使用嵌套规则，甚至能像编程语言一样定义变量、写条件判断和循环语句，大大增强了样式语言的灵活性，解决原生 CSS 的**开发体验问题**。\n' +
          '2. `CSS Modules`：能将 CSS 类名处理成哈希值，这样就可以避免同名的情况下**样式污染**的问题。\n' +
          '3. CSS 后处理器`PostCSS`，用来解析和处理 CSS 代码，可以实现的功能非常丰富，比如将 `px` 转换为 `rem`、根据目标浏览器情况自动加上类似于`--moz--`、`-o-`的属性前缀等等。\n' +
          '4. `CSS in JS` 方案，主流的包括`emotion`、`styled-components`等等，顾名思义，这类方案可以实现直接在 JS 中写样式代码，基本包含`CSS 预处理器`和 `CSS Modules` 的各项优点，非常灵活，解决了开发体验和全局样式污染的问题。\n' +
          '5. CSS 原子化框架，如`Tailwind CSS`、`Windi CSS`，通过类名来指定样式，大大简化了样式写法，提高了样式开发的效率，主要解决了原生 CSS **开发体验**的问题。\n' +
          '\n' +
          '不过，各种方案没有孰优孰劣，各自解决的方案有重叠的部分，但也有一定的差异，大家可以根据自己项目的痛点来引入。接下来，我们进入实战阶段，在 Vite 中应用上述常见的 CSS 方案。\n' +
          '\n' +
          '###  CSS 预处理器\n' +
          '\n' +
          'Vite 本身对 CSS 各种预处理器语言(`Sass/Scss`、`Less`和`Stylus`)做了内置支持。也就是说，即使你不经过任何的配置也可以直接使用各种 CSS 预处理器。我们以 `Sass/Scss` 为例，来具体感受一下 Vite 的`零配置`给我们带来的便利。\n' +
          '\n' +
          '由于 Vite 底层会调用 CSS 预处理器的官方库进行编译，而 Vite 为了实现按需加载，并没有内置这些工具库，而是让用户根据需要安装。因此，我们首先安装 Sass 的官方库，安装命令如下:\n' +
          '```bash\n' +
          'pnpm i sass -D\n' +
          '```\n' +
          '\n' +
          '然后，在上一节初始化后的项目中新建 `src/components/Header` 目录，并且分别新建`index.tsx` 和 `index.scss`文件，代码如下:\n' +
          '\n' +
          '```ts\n' +
          '// index.tsx\n' +
          "import './index.scss';\n" +
          'export function Header() {\n' +
          '  return <p className="header">This is Header</p>\n' +
          '};\n' +
          '\n' +
          '// index.scss\n' +
          '.header {\n' +
          '  color: red;\n' +
          '}\n' +
          '```\n' +
          '这样就完成了一个最简单的 demo 组件。接着我们在 `App.tsx` 应用这个组件:\n' +
          '```ts\n' +
          'import { Header } from "./components/Header";\n' +
          '\n' +
          'function App() {\n' +
          '  return (\n' +
          '    <div>\n' +
          '      <Header />\n' +
          '    </div>\n' +
          '  );\n' +
          '}\n' +
          '\n' +
          'export default App;\n' +
          '```\n' +
          '现在你可以执行`pnpm run dev`，然后到浏览器上查看效果:\n' +
          '\n' +
          '![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f2b53ea3fd74ef6bd7029749a282b91~tplv-k3u1fbpfcp-watermark.image?)\n' +
          '\n' +
          '内容比较简单，如果页面出现红色的文字部分，就说明 `scss` 文件中的样式已经成功生效。好，现在我们封装一个全局的主题色，新建`src/variable.scss`文件，内容如下:\n' +
          '```scss\n' +
          '// variable.scss\n' +
          '$theme-color: red;\n' +
          '```\n' +
          '然后，我们在原来 Header 组件的样式中应用这个变量:\n' +
          '```scss\n' +
          '@import "../../variable";\n' +
          '\n' +
          '.header {\n' +
          '  color: $theme-color;\n' +
          '}\n' +
          '```\n' +
          '回到浏览器访问页面，可以看到样式依然生效。你可能会注意到，每次要使用`$theme-color`属性的时候我们都需要手动引入`variable.scss`文件，那有没有自动引入的方案呢？这就需要在 Vite 中进行一些自定义配置了，在配置文件中增加如下的内容:\n' +
          '```ts\n' +
          '// vite.config.ts\n' +
          "import { normalizePath } from 'vite';\n" +
          '// 如果类型报错，需要安装 @types/node: pnpm i @types/node -D\n' +
          "import path from 'path';\n" +
          '\n' +
          '// 全局 scss 文件的路径\n' +
          '// 用 normalizePath 解决 window 下的路径问题\n' +
          "const variablePath = normalizePath(path.resolve('./src/variable.scss'));\n" +
          '\n' +
          '\n' +
          'export default defineConfig({\n' +
          '  // css 相关的配置\n' +
          '  css: {\n' +
          '    preprocessorOptions: {\n' +
          '      scss: {\n' +
          '        // additionalData 的内容会在每个 scss 文件的开头自动注入\n' +
          '        additionalData: `@import "${variablePath}";`\n' +
          '      }\n' +
          '    }\n' +
          '  }\n' +
          '})\n' +
          '```\n' +
          '现在你可以直接在文件中使用全局文件的变量，相当于之前手动引入的方式显然方便了许多:\n' +
          '```scss\n' +
          '.header {\n' +
          '  color: $theme-color;\n' +
          '}\n' +
          '```\n' +
          '同样的，你可以对 `less`和`stylus`进行一些能力的配置，如果有需要你可以去下面的官方文档中查阅更多的配置项:\n' +
          '\n' +
          '- [Sass](https://sass-lang.com/documentation/js-api/modules#render)\n' +
          '- [Less](https://lesscss.org/usage/#less-options)\n' +
          '- [Stylus](https://stylus-lang.com/docs/js.html)\n' +
          '\n' +
          '### CSS Modules\n' +
          'CSS Modules 在 Vite 也是一个开箱即用的能力，Vite 会对后缀带有`.module`的样式文件自动应用 CSS Modules。接下来我们通过一个简单的例子来使用这个功能。\n' +
          '\n' +
          '首先，将 Header 组件中的`index.scss`更名为`index.module.scss`，然后稍微改动一下`index.tsx`的内容，如下:\n' +
          '```ts\n' +
          '// index.tsx\n' +
          "import styles from './index.module.scss';\n" +
          'export function Header() {\n' +
          '  return <p className={styles.header}>This is Header</p>\n' +
          '};\n' +
          '```\n' +
          '现在打开浏览器，可以看见 p 标签的类名已经被处理成了哈希值的形式:\n' +
          '\n' +
          '\n' +
          '![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b81adefe16484da98bebf6174db36300~tplv-k3u1fbpfcp-watermark.image?)\n' +
          '\n' +
          '说明现在 CSS Modules 已经正式生效了！同样的，你也可以在配置文件中的`css.modules`选项来配置 CSS Modules 的功能，比如下面这个例子:\n' +
          '```ts\n' +
          '// vite.config.ts\n' +
          'export default {\n' +
          '  css: {\n' +
          '    modules: {\n' +
          '      // 一般我们可以通过 generateScopedName 属性来对生成的类名进行自定义\n' +
          '      // 其中，name 表示当前文件名，local 表示类名\n' +
          '      generateScopedName: "[name]__[local]___[hash:base64:5]"\n' +
          '    },\n' +
          '    preprocessorOptions: {\n' +
          '      // 省略预处理器配置\n' +
          '    }\n' +
          '\n' +
          '  }\n' +
          '}\n' +
          '```\n' +
          '再次访问页面，我们可以发现刚才的类名已经变成了我们自定义的形式:\n' +
          '\n' +
          '![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fc26be6dffd4b13b8b15603ba069f62~tplv-k3u1fbpfcp-watermark.image?)\n' +
          '\n' +
          '这是一个 CSS Modules 中很常见的配置，对开发时的调试非常有用。其它的一些配置项不太常用，大家可以去这个[地址](https://github.com/madyankin/postcss-modules)进行查阅。\n' +
          '\n' +
          '### PostCSS\n' +
          '\n' +
          '一般你可以通过 `postcss.config.js` 来配置 postcss ，不过在 Vite 配置文件中已经提供了 PostCSS 的配置入口，我们可以直接在 Vite 配置文件中进行操作。\n' +
          '\n' +
          '首先，我们来安装一个常用的 PostCSS 插件——`autoprefixer`:\n' +
          '```bash\n' +
          'pnpm i autoprefixer -D\n' +
          '```\n' +
          '这个插件主要用来自动为不同的目标浏览器添加样式前缀，解决的是浏览器兼容性的问题。接下来让我们在 Vite 中接入这个插件:\n' +
          '\n' +
          '```ts\n' +
          '// vite.config.ts 增加如下的配置\n' +
          "import autoprefixer from 'autoprefixer';\n" +
          '\n' +
          'export default {\n' +
          '  css: {\n' +
          '    // 进行 PostCSS 配置\n' +
          '    postcss: {\n' +
          '      plugins: [\n' +
          '        autoprefixer({\n' +
          '          // 指定目标浏览器\n' +
          "          overrideBrowserslist: ['Chrome > 40', 'ff > 31', 'ie 11']\n" +
          '        })\n' +
          '      ]\n' +
          '    }\n' +
          '  }\n' +
          '}\n' +
          '```\n' +
          '配置完成后，我们回到 Header 组件的样式文件中添加一个新的 CSS 属性:\n' +
          '```css\n' +
          '.header {\n' +
          '  <!-- 前面的样式省略 -->\n' +
          '  text-decoration: dashed;\n' +
          '}\n' +
          '```\n' +
          '\n' +
          '你可以执行`pnpm run build`命令进行打包，可以看到产物中自动补上了浏览器前缀，如:\n' +
          '```css\n' +
          '._header_kcvt0_1 {\n' +
          '  <!-- 前面的样式省略 -->\n' +
          '  -webkit-text-decoration: dashed;\n' +
          '  -moz-text-decoration: dashed;\n' +
          '  text-decoration: dashed;\n' +
          '}\n' +
          '```\n' +
          '\n' +
          '由于有 CSS 代码的 AST (抽象语法树)解析能力，PostCSS 可以做的事情非常多，甚至能实现 CSS 预处理器语法和 CSS Modules，社区当中也有不少的 PostCSS 插件，除了刚刚提到的`autoprefixer`插件，常见的插件还包括:\n' +
          '- [postcss-pxtorem](https://github.com/cuth/postcss-pxtorem)： 用来将 px 转换为 rem 单位，在适配移动端的场景下很常用。\n' +
          '- [postcss-preset-env](https://github.com/csstools/postcss-preset-env): 通过它，你可以编写最新的 CSS 语法，不用担心兼容性问题。\n' +
          '- [cssnano](https://github.com/cssnano/cssnano): 主要用来压缩 CSS 代码，跟常规的代码压缩工具不一样，它能做得更加智能，比如提取一些公共样式进行复用、缩短一些常见的属性值等等。\n' +
          '\n' +
          '关于 PostCSS 插件，这里还给大家推荐一个站点：https://www.postcss.parts/ ，你可以去里面探索更多的内容。\n' +
          '\n' +
          '### CSS In JS\n' +
          '\n' +
          '社区中有两款主流的`CSS In JS` 方案: `styled-components`和`emotion`。\n' +
          '\n' +
          '对于 CSS In JS 方案，在构建侧我们需要考虑`选择器命名问题`、`DCE`(Dead Code Elimination 即无用代码删除)、`代码压缩`、`生成 SourceMap`、`服务端渲染(SSR)`等问题，而`styled-components`和`emotion`已经提供了对应的 babel 插件来解决这些问题，我们在 Vite 中要做的就是集成这些 babel 插件。\n' +
          '\n' +
          '具体来说，上述的两种主流 CSS in JS 方案在 Vite 中集成方式如下:\n' +
          '```ts\n' +
          '// vite.config.ts\n' +
          "import { defineConfig } from 'vite'\n" +
          "import react from '@vitejs/plugin-react'\n" +
          '\n' +
          '// https://vitejs.dev/config/\n' +
          'export default defineConfig({\n' +
          '  plugins: [\n' +
          '    react({\n' +
          '      babel: {\n' +
          '        // 加入 babel 插件\n' +
          '        // 以下插件包都需要提前安装\n' +
          '        // 当然，通过这个配置你也可以添加其它的 Babel 插件\n' +
          '        plugins: [\n' +
          '          // 适配 styled-component\n' +
          '          "babel-plugin-styled-components"\n' +
          '          // 适配 emotion\n' +
          '          "@emotion/babel-plugin"\n' +
          '        ]\n' +
          '      },\n' +
          '      // 注意: 对于 emotion，需要单独加上这个配置\n' +
          '      // 通过 `@emotion/react` 包编译 emotion 中的特殊 jsx 语法\n' +
          '      jsxImportSource: "@emotion/react"\n' +
          '    })\n' +
          '  ]\n' +
          '})\n' +
          '```\n' +
          '\n' +
          '\n' +
          '### CSS 原子化框架\n' +
          '\n' +
          '在目前的社区当中，CSS 原子化框架主要包括`Tailwind CSS` 和 `Windi CSS`。Windi CSS 作为前者的替换方案，实现了按需生成 CSS 类名的功能，开发环境下的 CSS 产物体积大大减少，速度上比`Tailwind CSS v2`快 20~100 倍！当然，Tailwind CSS 在 v3 版本也引入 [JIT(即时编译)](https://v2.tailwindcss.com/docs/just-in-time-mode) 的功能，解决了开发环境下 CSS 产物体积庞大的问题。接下来我们将这两个方案分别接入到 Vite 中，在实际的项目中你只需要使用其中一种就可以了。我个人比较喜欢 Windi CSS 本身的`attributify`、`shortcuts`等独有的特性，因此首先从 windicss 开始说起。\n' +
          '\n' +
          '#### 1. Windi CSS 接入\n' +
          '\n' +
          '首先安装 `windicss` 及对应的 Vite 插件:\n' +
          '```\n' +
          'pnpm i windicss vite-plugin-windicss -D\n' +
          '```\n' +
          '随后我们在配置文件中来使用它:\n' +
          '```ts\n' +
          '// vite.config.ts\n' +
          'import windi from "vite-plugin-windicss";\n' +
          '\n' +
          'export default {\n' +
          '  plugins: [\n' +
          '    // 省略其它插件\n' +
          '    windi()\n' +
          '  ]\n' +
          '}\n' +
          '```\n' +
          '接着要注意在`src/main.tsx`中引入一个必需的 import 语句:\n' +
          '```ts\n' +
          '// main.tsx\n' +
          '// 用来注入 Windi CSS 所需的样式，一定要加上！\n' +
          'import "virtual:windi.css";\n' +
          '```\n' +
          '这样我们就完成了 Windi CSS 在 Vite 中的接入，接下来我们在 Header 组件中来测试，组件代码修改如下:\n' +
          '```tsx\n' +
          '// src/components/Header/index.tsx\n' +
          'import { devDependencies } from "../../../package.json";\n' +
          '\n' +
          'export function Header() {\n' +
          '  return (\n' +
          '    <div className="p-20px text-center">\n' +
          '      <h1 className="font-bold text-2xl mb-2">\n' +
          '        vite version: {devDependencies.vite}\n' +
          '      </h1>\n' +
          '    </div>\n' +
          '  );\n' +
          '}\n' +
          '```\n' +
          '启动项目可以看到如下的效果，说明样式已经正常生效:\n' +
          '\n' +
          '![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/365202ff835848558a2fd69cffd97d83~tplv-k3u1fbpfcp-watermark.image?)\n' +
          '\n' +
          '除了本身的原子化 CSS 能力，Windi CSS 还有一些非常好用的高级功能，在此我给大家推荐自己常用的两个能力: **attributify** 和 **shortcuts**。\n' +
          '\n' +
          '要开启这两个功能，我们需要在项目根目录新建`windi.config.ts`，配置如下:\n' +
          '```ts\n' +
          'import { defineConfig } from "vite-plugin-windicss";\n' +
          '\n' +
          'export default defineConfig({\n' +
          '  // 开启 attributify\n' +
          '  attributify: true,\n' +
          '});\n' +
          '```\n' +
          '首先我们来看看`attributify`，翻译过来就是`属性化`，也就是说我们可以用 props 的方式去定义样式属性，如下所示:\n' +
          '```html\n' +
          '<button \n' +
          '  bg="blue-400 hover:blue-500 dark:blue-500 dark:hover:blue-600"\n' +
          '  text="sm white"\n' +
          '  font="mono light"\n' +
          '  p="y-2 x-4"\n' +
          '  border="2 rounded blue-200"\n' +
          '>\n' +
          '  Button\n' +
          '</button>\n' +
          '```\n' +
          '这样的开发方式不仅省去了繁琐的 className 内容，还加强了语义化，让代码更易维护，大大提升了开发体验。\n' +
          '\n' +
          '不过使用`attributify`的时候需要注意类型问题，你需要添加`types/shim.d.ts`来增加类型声明，以防类型报错:\n' +
          '```ts\n' +
          "import { AttributifyAttributes } from 'windicss/types/jsx';\n" +
          '\n' +
          "declare module 'react' {\n" +
          '  type HTMLAttributes<T> = AttributifyAttributes;\n' +
          '}\n' +
          '```\n' +
          '\n' +
          '`shortcuts` 用来封装一系列的原子化能力，尤其是一些常见的类名集合，我们在 `windi.config.ts`来配置它:\n' +
          '```ts\n' +
          '//windi.config.ts\n' +
          'import { defineConfig } from "vite-plugin-windicss";\n' +
          '\n' +
          'export default defineConfig({\n' +
          '  attributify: true,\n' +
          '  shortcuts: {\n' +
          '    "flex-c": "flex justify-center items-center",\n' +
          '  }\n' +
          '});\n' +
          '```\n' +
          '比如这里封装了`flex-c`的类名，接下来我们可以在业务代码直接使用这个类名:\n' +
          '```HTML\n' +
          '<div className="flex-c"></div>\n' +
          '<!-- 等同于下面这段 -->\n' +
          '<div className="flex justify-center items-center"></div>\n' +
          '```\n' +
          '如果你也有过 Windi CSS 的开发经历，欢迎把你用到的高级功能分享到评论区，让大家一起来见识见识。\n' +
          '\n' +
          '#### 2. Tailwind CSS\n' +
          '\n' +
          '接下来我们来接入 Tailwind CSS 方案，为了避免和之前的 Windi CSS 混淆，这里我建议你新起一个 Vite 项目。\n' +
          '> 小册中对应的 GitHub [代码地址](https://github.com/sanyuan0704/juejin-book-vite/tree/main/other/ta'... 1437 more characters,
        is_free: 0,
        read_time: 2084,
        read_count: 8055,
        comment_count: 83,
        ctime: 1643517556,
        mtime: 1643517556,
        is_update: 0,
        draft_read_time: 2084,
        vid: '',
        reading_progress: {
          id: 0,
          booklet_id: '7050063811973218341',
          user_id: '3289337926283534',
          section_id: '7057872229589057576',
          reading_end: 0,
          reading_progress: 100,
          reading_position: 0,
          has_update: 1,
          last_rtime: 1663414496,
          ctime: 1656249641,
          mtime: 1663414495
        }
      }
    }
  },
  level: 'info',
  label: 'juejin',
  timestamp: '2022-09-18 01:43:26.397 PM'
}
